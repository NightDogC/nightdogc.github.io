[{"categories":["Unreal"],"content":"\r警告\r这是一个非计算机背景虚幻入门人员的个人探索，仅记录个人学习时想法和思考过程用，可能会看到各种奇奇怪怪的错误和“这不理所应当知道的知识？”，十分不建议参考。\r未完成\r本篇还没算写完，请尽快更新\r","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:0:0","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"综述 保存游戏，可以说是一个游戏中最重要的功能之一。根据虚幻官方文档的说法，保存游戏在游戏开发的早期就应该被设计出来： Every game needs to come up with a carefully thought out save game management plan early in the game’s development. 这点在做自己个人作品的时候就吃了亏，把保存游戏放到了最后实现，存还是能存，不过也就是在一个一本道流程里保存一下当前关卡id而已，好在作品简单，整体影响不大。 这么一个重要的功能，虚幻已经帮我们实现好了一套使用序列化的保存游戏功能USaveGame，如果在网上搜索虚幻保存游戏，无外乎都是教你如何调用USaveGame的API，但问题来了（也可能是我搜索能力还不够），光是调用API还不够，如何去设计一个游戏的保存功能呢？ 大部分教程显然做得不够好，甚至有为了演示API直接把API调用写在Character类里的，因为他要存Character的HP数据。这里实际上会有两个问题，一是这么做本事其实是没问题的，但考虑到OO，Character在一个游戏里大概率不是上帝，拥有“保存”这种“能力”不太合适，我们需要一个设计来支持较大项目的保存。而第二个问题，面对一些中型以上的游戏，我们希望能保存各种各样的东西：敌人打到一半时它的状态、解谜过程中关卡的进度、玩家做任务的进度、甚至整个世界的进度等等，而不是保存玩家本身的状态就行了。 关于第二个问题，虚幻其实也有招，一是所有的UObject都继承了Serialize()支持序列化，二是虚幻在反射系统中提供了一个SaveGame标识符，这使得可以在UObject序列化的时候，有选择地将标识了SaveGame的属性进行保存，详细操作教程看Helo老师这篇即可： UE4/UE5中保存游戏的基础知识 —— Basics about SaveGame in UE4/UE5 那么回到第一个问题，有了这套东西，以我目前的水平来说的一个想法是，可不可以设计一个组件或者接口，组合或接入想要保存的重要Actor，然后通过一个子系统进行管理？ 但是先别急，对目前的我来说，胡乱进行设计不可取。事实上，保存功能不只是游戏，下至notepad，上至操作系统，undo和redo功能可太常见了，因此是有一个专门为此的设计模式的：C++设计模式——备忘录模式(Memento Pattern) 那么，结合大钊老师InsideUE的说法，USaveGame基本就是这个Memento了，剩下的就难以界定了，GameInstance、GameModeBase、各种State类、或者做一个SaveGameSubsystem去做剩下的事好像也都还行，毕竟虚幻直接为我们提供了CreateSaveGameObject、SaveGameToSlot、LoadGameFromSlot等等API，但为了尽可能地符合单一职责原则，也为了封装保存的数据，我们肯定还是希望专门有一个东西能够来负责这件事。 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:0","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"项目参考 - Tomlooman - ActionRoguelike 终于到了参考别人项目的时候了，在众多不错的项目中，Tomlooman老师的ActionRoguelike的思路一眼看上去和我刚才的想法类似，可以看看他的具体实现。除此之外，虚幻4的ActionRPG里继承了USaveGame并重载了USaveGame的Serialize()，使得支持不同版本的存档，也是个不错的参考。 首先是Tomlooman老师的ActionRoguelike，他还贴心的写了一篇教程：Unreal Engine C++ Save System (SaveGame) ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:0","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"运用接口 在该项目中，对于想要保存的Actor接入了一个 GameplayInterface 接口，并在其中声明了OnActorLoaded() 注意\r这个接口是Tomlooman老师复用的一个接口，里面的其余函数声明和保存无关。 在自己实践时，尽量提供纯粹为了保存使用的接口，并给予接口正确的命名。 在这里使用接口的一个好处是，既可以对需要保存的Actor进行标记，又可以通过 OnActorLoaded() 去实现一些加载后的逻辑。当然，这部分逻辑在BeginPlay()里写也是一样的，只要确保你能在Actor的BeginPlay()调用之前加载好数据。 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:1","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"数据类型 然后是用于保存数据的Struct： USTRUCT() struct FActorSaveData { GENERATED_BODY() public: /* Identifier for which Actor this belongs to */ UPROPERTY() FName ActorName; /* For movable Actors, keep location,rotation,scale. */ UPROPERTY() FTransform Transform; /* Contains all 'SaveGame' marked variables of the Actor */ UPROPERTY() TArray\u003cuint8\u003e ByteData; }; 注释很明白，但有两个可以思考的地方。 对于FTransform属性，确实理论上来说对于绝大部分的Actor来说，都需要记录位置信息，但是需不需要特意把这个属性拎出来呢，考虑以下几点： 对于PlayerState这样重要但没有位置信息的Actor，由于又需要为Player数据确定一个单独的ID，所以打算单独处理PlayerState的保存 对于这个游戏内容和游戏本身的设计来说，目前以及未来可能需要保存的东西来说都是有位置信息的 虚幻不推荐放置一个Manager类的Actor，进一步降低了没有位置信息的Actor需要保存的可能性 不过就算真的没有无SceneComponent的Actor需要保存，那还有另一个问题：假设我有一个东西，就想保存它的一个别的状态，它的位置可以改变，但是我希望它下次加载的时候能出现在默认位置 总之结合实际需求，决定这么做合不合适 使用ActorName来标记，没有什么问题，只是后续看到TomLooman老师又点出也可以考虑使用FGuid来标记，对于runtime生成的Actor更有效，以及也可以有更多的解决方案 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:2","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"将变量转换为二进制 其实这部分看这个也差不多：UE4/UE5中保存游戏的基础知识 —— Basics about SaveGame in UE4/UE5 但还是做一下笔记： 使用 FMemoryWriter 和 FObjectAndNameAsStringProxyArchive （都继承自 FArchive ）能够将变量转换为二进制 然后就是源码了： void USSaveGameSubsystem::WriteSaveGame() { // Clear arrays, may contain data from previously loaded SaveGame CurrentSaveGame-\u003eSavedPlayers.Empty(); CurrentSaveGame-\u003eSavedActors.Empty(); AGameStateBase* GS = GetWorld()-\u003eGetGameState(); if (GS == nullptr) { // Warn about failure to save? return; } // Iterate all player states, we don't have proper ID to match yet (requires Steam or EOS) for (int32 i = 0; i \u003c GS-\u003ePlayerArray.Num(); i++) { ASPlayerState* PS = Cast\u003cASPlayerState\u003e(GS-\u003ePlayerArray[i]); if (PS) { PS-\u003eSavePlayerState(CurrentSaveGame); break; // single player only at this point } } // Iterate the entire world of actors for (FActorIterator It(GetWorld()); It; ++It) { AActor* Actor = *It; // Only interested in our 'gameplay actors', skip actors that are being destroyed // Note: You might instead use a dedicated SavableObject interface for Actors you want to save instead of re-using GameplayInterface if (!IsValid(Actor) || !Actor-\u003eImplements\u003cUSGameplayInterface\u003e()) { continue; } FActorSaveData ActorData; ActorData.ActorName = Actor-\u003eGetFName(); ActorData.Transform = Actor-\u003eGetActorTransform(); // Pass the array to fill with data from Actor FMemoryWriter MemWriter(ActorData.ByteData); FObjectAndNameAsStringProxyArchive Ar(MemWriter, true); // Find only variables with UPROPERTY(SaveGame) Ar.ArIsSaveGame = true; // Converts Actor's SaveGame UPROPERTIES into binary array Actor-\u003eSerialize(Ar); // Here CurrentSaveGame is a member variable of type USSaveGame* CurrentSaveGame-\u003eSavedActors.Add(ActorData); } UGameplayStatics::SaveGameToSlot(CurrentSaveGame, CurrentSlotName, 0); OnSaveGameWritten.Broadcast(CurrentSaveGame); } USSaveGame 的头文件源码也放在这先： UCLASS() class ACTIONROGUELIKE_API USSaveGame : public USaveGame { GENERATED_BODY() public: UPROPERTY() TArray\u003cFPlayerSaveData\u003e SavedPlayers; /* Actors stored from a level (currently does not support a specific level and just assumes the demo map) */ UPROPERTY() TArray\u003cFActorSaveData\u003e SavedActors; FPlayerSaveData* GetPlayerData(APlayerState* PlayerState); }; ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:3","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"保存PlayerData 之前说过，对于APlayerState单独拎出来实现是有一定道理的，那么直接上源码： void ASPlayerState::SavePlayerState_Implementation(USSaveGame* SaveObject) { if (SaveObject) { // Gather all relevant data for player FPlayerSaveData SaveData; SaveData.Credits = Credits; SaveData.PersonalRecordTime = PersonalRecordTime; // Stored as FString for simplicity (original Steam ID is uint64) SaveData.PlayerID = GetUniqueId().ToString(); // May not be alive while we save if (APawn* MyPawn = GetPawn()) { SaveData.Location = MyPawn-\u003eGetActorLocation(); SaveData.Rotation = MyPawn-\u003eGetActorRotation(); SaveData.bResumeAtTransform = true; } SaveObject-\u003eSavedPlayers.Add(SaveData); } } 以及相关结构体： USTRUCT() struct FPlayerSaveData { GENERATED_BODY() public: /* Player Id defined by the online sub system (such as Steam) converted to FString for simplicity */ UPROPERTY() FString PlayerID; UPROPERTY() int32 Credits; /* Longest survival time */ UPROPERTY() float PersonalRecordTime; /* Location if player was alive during save */ UPROPERTY() FVector Location; /* Orientation if player was alive during save */ UPROPERTY() FRotator Rotation; /* We don't always want to restore location, and may just resume player at specific respawn point in world. */ UPROPERTY() bool bResumeAtTransform; }; ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:4","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"读取PlayerData void ASPlayerState::LoadPlayerState_Implementation(USSaveGame* SaveObject) { if (SaveObject) { FPlayerSaveData* FoundData = SaveObject-\u003eGetPlayerData(this); if (FoundData) { //Credits = SaveObject-\u003eCredits; // Makes sure we trigger credits changed event AddCredits(FoundData-\u003eCredits); PersonalRecordTime = FoundData-\u003ePersonalRecordTime; } else { UE_LOG(LogTemp, Warning, TEXT(\"Could not find SaveGame data for player id '%i'.\"), GetPlayerId()); } } } 以及USSaveGame里的GetPlayerData： FPlayerSaveData* USSaveGame::GetPlayerData(APlayerState* PlayerState) { if (PlayerState == nullptr) { return nullptr; } // Will not give unique ID while PIE so we skip that step while testing in editor. // UObjects don't have access to UWorld, so we grab it via PlayerState instead if (PlayerState-\u003eGetWorld()-\u003eIsPlayInEditor()) { UE_LOG(LogTemp, Log, TEXT(\"During PIE we cannot use PlayerID to retrieve Saved Player data. Using first entry in array if available.\")); if (SavedPlayers.IsValidIndex(0)) { return \u0026SavedPlayers[0]; } // No saved player data available return nullptr; } // Easiest way to deal with the different IDs is as FString (original Steam id is uint64) // Keep in mind that GetUniqueId() returns the online id, where GetUniqueID() is a function from UObject (very confusing...) FString PlayerID = PlayerState-\u003eGetUniqueId().ToString(); // Iterate the array and match by PlayerID (eg. unique ID provided by Steam) return SavedPlayers.FindByPredicate([\u0026](const FPlayerSaveData\u0026 Data) { return Data.PlayerID == PlayerID; }); } 那么，LoadPlayerState是怎么调用的呢？ 在这里： void USSaveGameSubsystem::HandleStartingNewPlayer(AController* NewPlayer) { ASPlayerState* PS = NewPlayer-\u003eGetPlayerState\u003cASPlayerState\u003e(); if (ensure(PS)) { PS-\u003eLoadPlayerState(CurrentSaveGame); } } 这显然不是终点，我们继续翻： void ASGameModeBase::HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer) { // Calling Before Super:: so we set variables before 'beginplayingstate' is called in PlayerController (which is where we instantiate UI) USSaveGameSubsystem* SG = GetGameInstance()-\u003eGetSubsystem\u003cUSSaveGameSubsystem\u003e(); SG-\u003eHandleStartingNewPlayer(NewPlayer); Super::HandleStartingNewPlayer_Implementation(NewPlayer); // Now we're ready to override spawn location // Alternatively we could override core spawn location to use store locations immediately (skipping the whole 'find player start' logic) SG-\u003eOverrideSpawnTransform(NewPlayer); } 到了这里，发现是对GameMode里生成Player的逻辑部分进行了重载。至于为什么分成两部分来实现，TomLooman老师的说法是，尽快加载以处理UI，然后等待Pawn生成，处理位置。 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:5","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"将二进制转为变量 这次使用 FMemoryReader 便可以在调用Serialize()时将二进制读取为变量了 void USSaveGameSubsystem::LoadSaveGame(FString InSlotName /*= \"\"*/) { // Update slot name first if specified, otherwise keeps default name SetSlotName(InSlotName); if (UGameplayStatics::DoesSaveGameExist(CurrentSlotName, 0)) { CurrentSaveGame = Cast\u003cUSSaveGame\u003e(UGameplayStatics::LoadGameFromSlot(CurrentSlotName, 0)); if (CurrentSaveGame == nullptr) { UE_LOG(LogTemp, Warning, TEXT(\"Failed to load SaveGame Data.\")); return; } UE_LOG(LogTemp, Log, TEXT(\"Loaded SaveGame Data.\")); // Iterate the entire world of actors for (FActorIterator It(GetWorld()); It; ++It) { AActor* Actor = *It; // Only interested in our 'gameplay actors' if (!Actor-\u003eImplements\u003cUSGameplayInterface\u003e()) { continue; } for (FActorSaveData ActorData : CurrentSaveGame-\u003eSavedActors) { if (ActorData.ActorName == Actor-\u003eGetFName()) { Actor-\u003eSetActorTransform(ActorData.Transform); FMemoryReader MemReader(ActorData.ByteData); FObjectAndNameAsStringProxyArchive Ar(MemReader, true); Ar.ArIsSaveGame = true; // Convert binary array back into actor's variables Actor-\u003eSerialize(Ar); ISGameplayInterface::Execute_OnActorLoaded(Actor); break; } } } OnSaveGameLoaded.Broadcast(CurrentSaveGame); } else { CurrentSaveGame = Cast\u003cUSSaveGame\u003e(UGameplayStatics::CreateSaveGameObject(USSaveGame::StaticClass())); UE_LOG(LogTemp, Log, TEXT(\"Created New SaveGame Data.\")); } } 顺便也看看调用： void ASGameModeBase::InitGame(const FString\u0026 MapName, const FString\u0026 Options, FString\u0026 ErrorMessage) { Super::InitGame(MapName, Options, ErrorMessage); // (Save/Load logic moved into new SaveGameSubsystem) USSaveGameSubsystem* SG = GetGameInstance()-\u003eGetSubsystem\u003cUSSaveGameSubsystem\u003e(); // Optional slot name (Falls back to slot specified in SaveGameSettings class/INI otherwise) FString SelectedSaveSlot = UGameplayStatics::ParseOption(Options, \"SaveGame\"); SG-\u003eLoadSaveGame(SelectedSaveSlot); } 加载关卡时有个注意事项，现在太晚了，有空补上。 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:6","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"补充 那么，这套系统还需要补充什么地方？ 显而易见地，对于Destroyed的Actor，通过这样的方法是保存不到的。目前我自己有考虑一些方案，可能不是很成熟就不提出来了。 另外，如果实现联机，有关获取PlayerState的问题的参考如下： 客户端获取Actor PlayerController的途径有Server SetOwner-\u003eClient GetOwner，但不唯一。通过在Server记录PlayerController准确的Index然后传给Client，让Client使用GetPlayerController（Index）能获取到正确的PlayerController；使用PlayerState，GetPlayerStatus-\u003eGetPlayerID-\u003eGetPlayerControllerFromID亦可得到正确的PlayerController。 From：UE4笔记8：多人情况下获取玩家控制器的问题 最后，对于额外的关卡流保存和加载，可以参考 Steve’s Library（很强） ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:7","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"还有一些？ 太晚了现在，本来是讲系统设计的结果教程看着看着就关注实现了，教程的最后总结也没细看，这两点后续要补充。代码也只是复制粘贴没详细说说，这么直接复制粘贴人家代码也不太好。。。以后会换成自己的理解，代码还请上人家自己网站上看。最后ActionRPG的保存版本功能也没来得及说。 目前还是属于对人家的一个搬运，没什么自己的东西，但为了方便自己看，还是先发布了，哎。 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:2:8","tags":["Unreal","个人探索","保存游戏","开发设计"],"title":"【个人探索】研究一下保存游戏的设计","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"本次笔记的课程为 大钊-虚幻C++的进阶之路 里面简单介绍了一下UnrealC++的学习路径、Module-UBT-C#相关、反射-UHT相关、对象类型相关（顺便自己摘抄了一点软引用的东西） 由于内容较多，体系完整，基本上属于是摘抄PTT和发言，方便以后随时回看，后续会根据此篇写一篇针对个人的学习路径 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:0:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"什么是虚幻C++ 扎实的标准C++基础能力 采用C++编写游戏逻辑 适应虚幻引擎的底层C++框架 Module配置和插件的使用 UBT和UHT（编译工具、头文件生成工具） 掌握Core模块的C++库：FString、TArray、UE_LOG等 熟悉了解掌握CoreUObject：宏、GC、序列化等 熟悉C++和BP交互的方式 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:1:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"学会虚幻C++的标志是什么？ 懂得解决各种编译链接错误（常是因为Module配置出错） 懂得一些常见的编写套路（CreateDefaultSubobject、UPROPERTY的标识符） 理解UObject的内存管理机制，不会经常造成内存崩溃 可以在源码里找到自己想要的代码块 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:1:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"为什么虚幻要开放C++来编写Gameplay 更高端，更需要压榨机能 更底层，更有能力优化性能 更大项目，强类型语言更有能力管理项目 更开放，更有灵活的定制型 更易迭代，不需要时时更新接口层 更相信开发者，进入了C++这个自由的领域，就得有自我负责的觉悟 方便扩展功能，直达引擎的底层结构 更好的性能，性能热点的优化 方便调试引擎，理解引擎流程和修复bug 大项目必须有某种Hold得住的语言 没法实现定制化的需求 游戏逻辑只能达到有限的优化 项目大到一定程度就很难管理 最后一点，可以更好地学习游戏引擎知识，也可以理解别人写的插件 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:2:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"虚幻C++与蓝图？ 官方文档中游详细介绍虚幻C++与蓝图的优劣，它们都是工具，需要学的和做的事利用工具的优势 一般而言，20%核心用C++写，80%表层使用蓝图，但也不是绝对的，根据项目类型和个人技能而定 大概的规则： 偏向引擎底层，偏向性能热点，偏向稳定的，采用C++ 偏向表现层，偏向经常操作的，偏向多变的，采用蓝图 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:2:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"虚幻C++有哪些要点 C++的基础一定需要巩固（推荐书目InsideC++ObjectModel），Unreal使用C++11，所以需要学到能够看懂别人怎么用这些东西： TArray、TSet、TMap等各种容器 FString、FName、FText的操作互转 TSharedPtr、TSharedRef、TWeakPtr等各种智能指针 有能力理解Delegate、TAttribute、TSubclassOf的机制和用法 多看看设计模式，才能更好理解Unreal代码的结构 多线程的知识，才能用好FRunnable等多线程同步 人脑展开宏的能力（脑子里要能堆栈） Core，即Engine/Source/Runtime/Core部分的内容 Gameplay部分，详见InsideUE Module、UBT、C# 反射、UHT CoreUObject（也在Engine/Source/Runtime/）、GC 常见套路 各模块的\"地方习俗\"，专攻时学习 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"Gameplay部分 Gameplay的C++编写 Actor的创建，组装Component，BeginPlay，Tick，碰撞输入事件绑定 引擎Gameplay对象的继承组织使用 UObject自定义对象的组织管理（根据逻辑而定）（NewObject、CreateDefaultSubobject、SpawnActor） 引擎数据对象的使用，Config，DataTable 功能模块的C++层级编写（UMG、AI、动画等），注意有机结合 学习Egine/Class/GameFramework模块代码 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"Module、UBT、C# Unreal使用C#来管理编译流程，深入到模块链接的时候就会接触到 C++以一个cpp文件为一个编译单元，编译阶段时，根据include预编译指令，将包含的文件复制粘贴进来，那么1.该上哪里去找这些文件，该如何定位它们；2.然后在LINK阶段，需要怎么链接dll 为了解决这两个问题，中间需要很多逻辑与配置，比如模块与模块之间要怎样做，编辑器情况下要怎么样，等等 UE4支持众多平台，包括Windows，IOS，Android等，因此UE4为了方便你配置各个平台的参数和编译选项，简化编译流程,UE4实现了自己的一套编译系统，否则我们就得接受各个平台再单独配置一套项目之苦了。\u000b这套工具的编译流程结果，简单来说，就是你在VS里的运行，背后会运行UE4的一些命令行工具来完成编译，其他最重要的两个组件： UnrealBuildTool（UBT，C#）：UE4的自定义工具，来编译UE4的逐个模块并处理依赖等。我们编写的Target.cs，Build.cs都是为这个工具服务的。 UnrealHeaderTool （UHT，C++）：UE4的C++代码解析生成工具，我们在代码里写的那些宏UCLASS等和#include “*.generated.h\"都为UHT提供了信息来生成相应的C++反射代码。\u000b一般来说，UBT会先调用UHT会先负责解析一遍C++代码，生成相应其他代码。然后开始调用平台特定的编译工具(VisualStudio,LLVM)来编译各个模块。最后启动Editor或者是Game. 优点：C#足够易读，C#足够灵活定制逻辑，C#可以动态编译，方便搜集信息，C#足够强大可以调用其他工具(如调用Git确定哪里被修改了，调用VS的编译工具等等） 缺点：C#和C++混合经常搞得有些人糊涂，C++项目里混进C#没有智能提示不够友好 解决：常见的错误都是这两者报出的，记住常用用法就行了，有问题再查。 悄悄说，UBT用的是NMake build system 所以常见的错误一般都是宏写错了、.h位置不对（UHT报出来的）、编译错误（UBT报出来的） 学会链接模块，项目和插件可包含多个模块 UBT调用UHT生成代码，然后调用MSBuild编译代码 Build.cs是重点（ModuleRules.cs） 点下Build后UBT做了哪些事情 首先UBT会去搜集目录里面的cs文件，获得配置信息 调用UHT，分析.cpp文件，根据include预编译指令和Unreal宏生成.generated.h文件（Intermediate路径下），此时如果宏没写对，这一步UHT就会报错 UBT调用MSBuild，把.cpp文件和.generated.h合到一起编译一下 ModuleRules.cs 模块链接 PublicDependencyModuleNames： public链接的模块名称，最常用 在自己的public和private里包含对方的public PrivateDependencyModuleNames： private链接的模块名称，只引用不暴露 在private里包含对方的public，不扩充自己的public DynamicallyLoadedModuleNames: 动态链接的模块名称，在runtime被ModuleManager加载，保证先编译 所谓自己的public和private就是Source文件夹里常有的Public和Private，在引擎源码部分里也可以看到 头文件include PublicIncludePaths： public包含的路径 定义自己向外暴露的public，默认”Public”和”Classes” PrivateIncludePaths： private包含的路径 定义自己的private，给自己内部引用，默认“Private”，一般用来定义Private子目录。当然也可以路径包含Private/Sub，但这是一种方便方式。 头文件include 模块 PublicIncludePathModuleNames： public包含的模块名称，可以只写模块名称 PrivateIncludePathModuleNames： private包含的模块名称，可以只写模块名称 用途： 只包含对方模块的.h文件，比如模板，虽然挺少见 更多是动态链接，先包含头文件信息，之后加载 第三方库链接 PublicAdditionalLibraries： 引用的第三方lib路径 PublicSystemLibraryPaths ：引用的系统lib路径，其实也只是lib，只不过对于一些更“系统”底层的库用这个名字更友好一些 PublicDelayLoadDLLs：延迟加载的dll 具体怎么用，可以在引擎源码里去找找，比如AlembicLib.build.cs 其它常用 PublicDefinitions + PrivateDefinitions ： 额外的其他C++宏定义 Target： 得到当前的编译目标信息 Platform：平台，Win64，Android，IOS Configuration：配置， Debug， Development， Shipping public和private包含 做的游戏的项目其实无所谓，但是如果涉及到给别人用的模块或者插件就需要注意，应当只给出调用，而不要把实现暴露出去 还是图比较直观： 如果A模块public包含B模块，那么A模块中的public和private中的文件都可以include模块B的文件 如果A模块private包含B模块，那么A模块中的public中的文件不能include模块B的文件，只有private中的文件可以include模块B的文件 所以什么时候用public包含，什么时候用private包含？ 当你写的这个模块所包含的模块也希望给别人使用时，public包含 当你写的这个模块所包含的模块不希望暴露给别人时，想让暴露的接口干净一点，private包含 总结一下，include头文件找不到的情况下，应当看看你包含的模块在Build.cs里是否有相应配置，.cpp文件include不到，看看你包含的模块在Build.cs里是否是private包含 另外，一般情况下而言，Class也属于Public。 所以，如果想要include一个文件，那么： 在Class/Public/Private路径前面的一个是其模块名，需要在Build.cs里包含 在Class/Public/Private路径后面的所有是你应该写在include的东西 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:2","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"反射、UHT 理解.generated.h和gen.cpp 理解MODULENAME_API的含义（常见的犯错地方），这个是用来做dll互相导出的 掌握使用这些宏的含义和用法（反射的重要标记，在ObjectMarcos.h里可以看到） UCLASS USTRUCT UENUM UPROPERTY UFUNCTION UINTERFACE GENERATED_BODY() 清晰理解类型和对象之间的关系：ClassReference Vs ObjectReference Object Reference，是一个对Actor实例的引用，即其引用的类被实例化，被引用的资源也会被实例化，被引用的资源都会加载到内存中 Class Reference，在C++中就是TSubclassOf\u003c\u003e，对一个UObject的class的引用，用处和TSubclassOf相同，即常用于创建对象和让美术师、设计师引用资源 其实还有SoftClassReference和SoftObjectReference，这两个是指内部存储的资源路径，使用时加入还未被加载则先加载再使用，还可以用作跨关卡的Actor的引用 SoftObjectReference等价于C++中的TSoftObjectPtr，引用了这个资源的路径，当无需此资源时，无需将资源加载到内存中，只要保存一个资源路径（实际上存了一个FSoftObjectPath结构体）就好，通过这个可以实现异步资源加载 SoftClassReference，等价于C++中的TSoftClassPtr，与TSoftObjectPtr不同的是，TSoftClassPtr返回的是这个UObject对应的UClass* 总的来说，TSoftClassPtr侧重于描述UObject的Class，一些配置扩展的class就可以用这个，比如伤害类型等，而TSoftObjectClass则引用一些 具体原因： 而TSoftObjectPtr侧重于描述某一类资源，比如静态模型、动态模型、数据表格等 对于FSoftObjectPath，可以用元数据标识符 meta = (AllowedClassed=\"Material,StaticMesh\") 来限定某种特定的资源 但，该元数据只能筛选现有资源类型，当需要自定义继承UObject的类想用这个就没办法了，所以这时候就需要FSoftClassPath，并说明元数据标识符： meta = (MetaClass = \"MyActor\") 关于资源加载也是一个大篇章，这里先简单介绍一下这两个软引用 理解UClass*、UScriptStruct*、UField*、UFunction*、UProperty* 掌握通过反射遍历对象属性、读取写入，较为常见 掌握通过反射遍历对象函数并调用的方式，用的少一点 通过对象找类型，通过类型找对象 理解\"对象用类型描述，类型本身又是对象”（C#表示确实） ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:3","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"CoreUObject GC、内存管理：理解对象之间的关系，标记清扫，有一些对象是Root 简单来说，没被引用的对象会被清扫，想要既不被引用又不被清扫，就需要添加到Root（这就是在Unreal里自己强行写单例模式会犯的各种错之一，不添加Root被当垃圾回收了） 注意只有UPROPERTY标记的才参加GC，因为要根据UPROERPTY来分析引用链，不写UPROPERTY的话请自己处理 注意FMyStruct和UObject的混用，FGCObject::AddReferencedObjects 不要在Unreal里写new和delete，这俩被Unreal重载了 CDO（ClassDefaultObject）：理解类型和对象实例化、模板 理解ClassDefaults作为模板的作用 理解CDO在序列化中的意义和作用 通过UClass::GetDefaultObject来获得CDO信息 Package：理解对象的相互组织方式 对象可以包含子对象 序列化时，把一系列对象用一个对象包起来，这个对象叫做包 Package也可以互相引用，根据对象的相对路径 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:4","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"套路 UHT的套路：宏 模块链接的套路：几个常用属性.AddRange Actor创建的套路： ConstructorHelpers（这属于hardcode资产，不太常用其实） CreateDefaultSubobject 设置一堆属性 SetupAttachment Gameplay继承的套路： 尽量别在关卡蓝图里写逻辑 想要结构良好，尽量遵循引擎结构，各司其事 GI、GM、GS、PC、Pawn、PS全都继承一波带走 遵循推荐结构，会发现后期扩展和支持联机有天然优势 C++和BP交互的套路： 各种标识符的使用 C++定义基类写逻辑，蓝图继承进行配置时钟推荐易扩展高性能的方式 蓝图函数库是个好东西 事件绑定的套路： DELEGATE、MULTICAST_DELEGATE、EVENT、DYNAMIC Input：BindAxis、BindAction Collision：Hit、Overlap、AddDynamic Slate\u0026UMG Event：SLATE_EVENT(FOnClicked, OnClicked) FTimerManager 引擎常用方法的套路： Engine/Class/Kismet这个路径下有很多库，有很多好东西，都是做好了的实用的功能 GameplayStatics很常用，可以访问GamePlay的很多对象 UKismetSystemLibrary，系统目录等功能，LineTrace UKismetMathLibrary，数学 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:5","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"虚幻C++有哪些难点 C++基础 数据结构算法，操作系统多线程 数学基础：线性代数、向量矩阵、牛顿力学 游戏开发知识基础：渲染、动画、AI 项目开发经验：如何设计一个\"足够好\"的项目代码框架 记住知识要点：各种宏和API ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:4:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"如何学习虚幻虚幻C++ 学习从模仿开始，形成肌肉记忆，也知道了去哪里抄 模板项目，官方项目等 模仿引擎源码，最权威也最节俭，缺点是首先要找得到，然后要看得懂 模仿社区项目，或者搞到的其他人的插件，缺点是水平参差不齐，一般写的比较杂乱，不要被带沟里，建议多讨论交流 多看一些教程文章和视频 勇敢尝试动手改改 着手微调一些地方观察变化 遵循套路增加一些功能看能否做到 翻翻找找.h或相关地方是否有好用的接口 总结规律 总结你发现到观察到的概念，规律，规范，注意事项 用工具记录下来，在社区分享贡献 善于积累 弄个测试项目，用一个最小的场景用于测试你想理解的功能 有用的代码功能块，可以用插件或函数库封装起来，在项目之间复用，形成代码资产 对于概念，可以用思维导图来分析理解，理清关系和区别 尝试自己画流程图，能用图表示出来才说明理解透彻 玩具项目实践 如自己做一些独立游戏项目，大大有助于自己思考项目架构 用项目级实践来考验自己的掌握能力 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:5:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"其它的一些Tips 用插件来在项目间共享代码，动手编码前多想想 变量类型尽量的偏向抽象基类，比如UStaticMeshComponent（甚至UMeshComponent，万一以后想要换成SkeletonMesh呢）和UPrimitiveComponent（TriggerActor就是用ShapeComponent变量） Include尽量IWYU，include what you use，加快编译速度 善用C++前置声明，减少include依赖，加快编译 蓝图函数库是个很有用的宝库 C++代码里不要写数据配置！尝试数据驱动！C++-\u003eBP-\u003eDataTable 蓝图也是要做好设计模式功能划分的，才能更好的协作 再说一次，项目一开始就C++定义基类+蓝图继承，后面肯定会发现这很有先见之明！ 没有C++基类的蓝图类，也可以reparent基类，记得先备份！ 重构了C++基类名字，导致蓝图找不到父类？用CoreRedirects来修复（详见官方文档） 如果可以不改引擎，尽量不改！就算编译版引擎也可以通过UObject来打洞Hack，和C++奇技淫巧来访问private成员。 如果想好要改，在改动上下包上宏或注释标记，以后merge方便。 一切从GEngine开始：UEngine*GEngine; UGameEngine/UEditorEngine 从GEngine可以开始获得Worlds，游戏播放和编辑的场景也都是个world 获取游戏视口进行slate叠加或截图等 GEditor对做编辑器扩展很有用：UEditorEngine* GEditor; 可以获得当前选择Actor等有用信息 可以获得当前视口 可以调用编辑器功能 可以获得事件回调 编辑器也是个游戏，也都是各种UObject组成的，所以只要你能获取到正确的对象，就能为所欲为了！ NewObject的背后，基本上所有的对象都存放在对象池里，意味着你能获取到任何对象。 Actor里是可以runtime动态创建添加Component的，想想Spline，想想编辑器本质只是在跑的一个Game。 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:6:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"源码剖析经验方法论 时空观 时：注重时间上的先后，观察函数的调用流程，事件的触发时机 空：注重数据的吞吐转换，观察信息的采集，数据的加工消化利用 有时要专注考察某一方面，有时要同时拥有两种脑袋 时空的交互，组成了有机的功能架构支撑，调度起资源，启动内循环，响应外部刺激 信息论 最小信息原则 = 依赖最少 = 越稳定 信息本质也是能量，只有掌握了足够的信息，才有足够能量实现某些功能 数据是信息，代码结构是信息，项目协作方式也是信息 从开始到结束 一开始有哪些东西？ 第一把点火的推力是什么？ 启动后自循环是那些推力？ 有哪些外部输入的刺激？ 向外部吐出了哪些数据？向外部施加了哪些力？ 最后剩下什么？ 保持谦逊但不迷信 首先怀疑是自己太傻，最后才觉得人家写的不够好。97.34%最终会发现是自己的问题。 觉得源码写得不够好，自己必须能切实的在充分理解问题区间的基础上指出错误并写出更好方案，否则没有资格批评！忌空谈！ 认识到引擎开发人员也是普通人，是人就会犯错。但大概率人家水平比自己高，小概率会疏忽。 认识到引擎是个历史悠久的大工程，里面充满了历史馈赠的遗产、包袱和迷雾。所以很多觉得不够好的原因是历史带来的，不应该过于苛责。 比起好奇心更应该保持耐心！ 常常会困惑这是干嘛的？ 常常会理解不了为什么这么做？有什么特殊的用意？ 数据用来用去，代码调来调去，感觉一团乱麻！ 调用链条太长，自己的脑容量堆栈不足以存储…… 所需的背景知识有欠缺…… 无人可问，孤军奋战…… 直面磅礴的源码库，深感自己的渺小！ 对引擎更新又激动又害怕，对自己一天只有24小时这个事实深感无力！ 承认自己是个凡人，余生只够掌握一小块知识，和自己妥协，从此虚心向别人请教，对别人的分享心存感激，为自己也能尽一份力分享而欣喜~ 工具越简单越好，专注核心内容，别浪费时间调整格式！ 放弃除了VS之外的源码阅读工具，额外的都是负担，间接一层就多了一层信息同步消耗。 放弃UML图系列工具，只取其思想，放弃其形式，对于上百个类来说，人类无法理解UML的哪怕各角度表达，更何况还得手调其格式排版，一半情况下每新加一个类都得调整一遍。 对于已经确定的内容，才需要画图来加深理解。别一边理解一边画图，90%时间在调整图排版。 我个人最后选择了思维导图，有不足，但足够简单可理解。 最后写文章，我用Markdown码字，Processon画流程图 调试过程： 开Debug配置编译源码，debug everything！编译选项说明见InsideUE基础概念一章 一边调试一边记录 在引擎源码内加debug输出，根据打印数据信息确定数据内容和先后 抓住主脉络，旁支情况记一下以后再收拾 技巧在于：找！顺藤摸瓜的找！ WidgetReflector定位代码块（Unreal菜单栏-Tools-Debug里面） VA 查找所有引用或调用 VS 字符串查找 Everything工具定位文件 开Debug断点查事件调用 功底体现在于：瞧的懂大概是咋回事 搬的技巧在： 能找到办法直接调用的就别拷贝代码 能否找到调用的代码路径的功底在于：能否事先理解各模块对象的组织关系，事先修行有必要 别在Runtime下想法子调用Editor的代码，不合法也费劲 找到目标代码块的：输入和输出，小心内部的依赖 自己嫁接过来的时候要想法子喂给足够的数据 如果是流程上插一脚的，想法子找到关键的“旋钮“ ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:6:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"【Unreal Nuggets】系列为记下来平时使用Unreal开发过程中的一些小Tips、小（骚）操作、以及一些临时去查的小特性小功能。 本篇主要为记录一些个人之前自己研究UE时用的比较少的一些蓝图流程控制节点、容器操作节点等等，在别的地方看见了会摘录到这里来。 使用多次以后也会相应地删除。 ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:0:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"蓝图连直线 讲道理默认那个扭曲的线条真的很丑（ ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:1:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"Gate Node ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:2:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"MultiGate Node ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:3:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"工作上出了点问题，本质上是对软件工程和设计模式还不够熟悉。姑且先不论之后进一步系统性的学习，首先还是要解决一下目前工作的问题，因此这个笔记属于一个临阵磨枪的性质，不会有深入的剖析，而是强行为个人接下来的实践服务，故谨慎参考。 在这之前，无论如何首先要把大钊的InsideUE中的Gameplay篇章快速过一遍，后续会再对InsideUE进行精读：大钊 - InsideUE4 另，本篇参考教程如下： [英文直播]和Tom Looman一起开发C++游戏玩法框架(官方字幕) [中文直播]第26期 | 虚幻引擎GamePlay框架理解与应用 | Epic 大钊 马骥 ART0189 - 游戏开发工程 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:0:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ActorComponent： 组件是种能力 为Actor提供能力 能力一般跟业务逻辑无关 能力是跨游戏的 一个问题：如果尝试采用组件化开发，在该游戏中有不同的Actor都需要应用同样一份业务逻辑，但是该逻辑不一定能被其他游戏用上，该怎么办呢？ 目前个人的想法是添加接口，即如果一定要用到别的游戏，也不是不可以，去把接口实现了就行。 例： 通用耐久度设计： 新建DurabilityInterface，提供函数： ConsumeDurability(float AlternativeEnemyATK); QueryDurability(); 整合耐久度系统至SuperDurabilityComponent，继承自UActorComponent、IDurabilityInterface 声明变量float Durability、float DurabilityHarmMultiplier 实现QueryDurability() { return Durability; } 创建子类WeaponDurabilityComponent、ArmorDurabilityComponent、PropDurabilityComponent 从PropDurabilityComponent创建子类TimeRelatedPropDurabilityComponent、FrequencyRelatedPropDurabilityComponent 在PropDurabilityComponent以外的各个子类实现ConsumeDurability(float AlternativeEnemyATK) ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:1:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ALevelScriptActor（关卡蓝图）： 对于项目来说，大部分情况下在关卡蓝图里并不适合写功能，最多适合一些Demo，快速地做一些功能验证 适合一些关卡本身的触发机械互动，且多为表现相关内容，比如到某处触发一段Sequence 一些关卡中机关的触发，虽然看似和关卡本身相关，但机关的触发本身在别的关卡中也需要有，因此触发机关的逻辑还是写在机关Actor本身上为好 Actor本身也是为了实现跨关卡的能力。 按我个人目前的理解，某个关卡中某个区域或整个关卡的的重力等这样的一些关卡配置逻辑或许也可以写进关卡蓝图中，但还是尽量谨慎吧。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:2:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"APawn、APlayerController和APlayerState Pawn相比Actor，足够复杂 Pawn、State、Controller一体，集成了MVC Pawn里面也要拒绝写入太过于庞大的逻辑和数据，这是不太好的 一个问题，那是不是意味着Controller里面要写全部的输入逻辑？ 不是的，输入逻辑写在哪里，关键看这个Pawn有没有这个功能，比如攻击、跳跃，这种接受输入的逻辑应当写在Pawn（Character）里，因为这是只有角色才有的功能，而Controller经过Unreal的封装，虽然写在了Pawn里，但由于有Possess这个接口，但实际上还是由Controller告诉Pawn：请攻击、请跳跃的。 而另一方面，一些“不是这个Pawn该有的功能”的输入操作，则应该写在Controller里，比如暂停、调出UI，应当写在Controller里 另一个问题，如果不同的Pawn之间有一些通用的功能，比如Character可以Fire，而炮塔也可以Fire，PlayerController既可以Possess炮塔，也可以Possess Character，那么接受Fire的输入的逻辑应该写在哪里呢？ 在我去翻项目工程之前，我自己的想法是在PlayerController里写Fire输入，Fire本身作为一个FireActorComponent，然后派生出炮塔FireActorComponent和CharacterFireActorComponent，分别实现Fireable接口中Fire()函数，PlayerController里Fire输入事件判断当前Pawn是否实现该接口 工程中则直接采用了接口，取消了一层AcotrComponent的继承关系，直接在炮塔BP和CharacterBP中实现接口。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:3:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"AController和APlayerState ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"AController 用来控制别的Actor的Actor ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:1","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"APlayerState 肉体的状态（抽离开是为了联机复制） ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:2","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"AIController AI是否有PlayerState？有，有一个Property是bWantsPlayerState ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:3","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ULevel和UWorld ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:5:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ULevel Actor的集合 World里的板块 对应umap ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:5:1","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"UWorld Level的集合 运行时，真正的Actor集合 “关卡”的真正单位 场景的真正表示对象 这个层级关系，主要还是涉及到StreamingLevel相关，详见InsideUE即可。 总之这里比较重要的还是强调一下，不要在关卡里写逻辑。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:5:2","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"GameMode和GameState GameMode实际上是定义的世界（World）的规则，可以理解成WorldMode，它来控制UWorld “上帝的意志” GameState则表示世界的状态 一个问题：如果有关于世界的规则越来越多，那么GameMode中的逻辑也会变得很庞大，该如何处理这种情况？ 见Subsystem ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:6:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"GameInstance和SaveGame GameInstance是正常游戏的全局示例 World的外围管理对象 所以会写一些跨关卡的逻辑 比如，存档，由于存档实在是太重要了，所以Unreal专门写了一个USaveGame类给开发者使用 SaveGame就是GameInstance层级的一个数据对象，当然，根据我的理解，GameInstance里也可以存放一些数据，这些数据是不需要进行序列化保存到本地，只需要在游戏运行期间使用就行的（当然要符合GameInstance这个层级），而需要保存到本地的则放在SaveGame里。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:7:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"USubsystem 业务逻辑的组件 5个生命周期粒度控制 自动生成对象 托管生命周期 替代Manager类 详见InsideUE ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:8:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"UI 创建UI，比较推荐写在PlayerController里，不要写在GameMode或者关卡蓝图里 这个是涉及一个联机问题，因为GameMode是不会在客户端里的，理论上单机游戏创建UI写在哪里都行，但是一旦联机还是写在本地会有的关联性也比较强的PlayerController里为好 或者，考虑Subsystem ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:9:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"总结：什么逻辑在那里 Component：功能、能力 Actor：个体本身的逻辑 Apawn、APlayerController、APlayerState：主角肉体、灵魂、状态 APawn、AAIController、APlayerState：AI肉体、灵魂、状态 AAIController、BehaviorTree：AI灵魂、行为树、数据 AGameMode、AGameState：游戏规则、游戏状态 UGameInstance、USaveGame：全局游戏实例、游戏存档 USubsystem：游戏逻辑组件 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:10:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"输入事件在那里处理 考虑联机扩展 APlayerController最优先 APawn其次 单独Actor且EnableInput 关卡蓝图：Demo测试 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:10:1","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Dev"],"content":"最基础的：斜体、加粗、粗斜体、Inline代码、删除线 ToDo Done ","date":"2022-10-29","objectID":"/posts/first/:0:0","tags":["格式"],"title":"内容格式参考模板","uri":"/posts/first/"},{"categories":["Dev"],"content":"一级标题 ","date":"2022-10-29","objectID":"/posts/first/:1:0","tags":["格式"],"title":"内容格式参考模板","uri":"/posts/first/"},{"categories":["Dev"],"content":"二级标题 三级标题 四级标题 引 用 简单代码块 有 序 列 表 无 序 列 表 嵌 套 列 表 公式： 在markdown中使用KaTeX公式，遇到 _ * \u003e\u003e \\( \\) \\{ \\} \\] \\[ 在前面都需要添加转义符 \\ 比较保险。 对于 \\\\ ，需要写成 \\\\\\\\ 公式块： $$ C(n,m)=\\frac{n*(n-1)*…*(n-m+1)}{m*(m-1)*…*1} $$ $$P(A|B)=\\cfrac{P(A)*P(B|A)}{P(B)}$$ 行内公式1： \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 行内公式2： \\(\\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots\\) 矩阵：$$\\begin{matrix} 1\u00262 \\\\ 3\u00264 \\\\ 5\u00266 \\end{matrix} $$ $$\\left\\{ \\begin{matrix} 1\u00262 \\\\ 3\u00264 \\\\ 5\u00266 \\end{matrix} \\right\\} $$ $$\\left[ \\begin{matrix} 1\u00262 \\\\ 3\u00264 \\\\ 5\u00266 \\end{matrix} \\right] $$ 快速分数： 99/100 额外空行： 表格： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 脚注： 使用1表示脚注 链接： 这是一个连接 加强代码块： #include \u003ciostream\u003e int main() { std::cout\u003c\u003c(\"Hello world!\"); return 0; } Admonition shortcode： tip\rA tip banner\rnote\rA note banner\rinfo\rA info banner\rSuccess\rA success banner\rabstract\rA abstract banner\rquestion\rA question banner\rwarning\rA warning banner\rfailure\rA failure banner\rdanger\rA danger banner\rbug\rA bug banner\rexample\rA example banner\rquote\rA quote banner\r添加B站视频（Youtube同理）： 添加本地音乐： 添加平台音乐（第二个参数song或者playlist或者album或者artist都行）： 添加平台音乐2： 添加脚本： 图片： 带脚注图片： 这样会自动放缩并居中\r行内图片，自定义大小： 图片居中，自定义大小，带脚注： 这是一个脚注 ↩︎ ","date":"2022-10-29","objectID":"/posts/first/:1:1","tags":["格式"],"title":"内容格式参考模板","uri":"/posts/first/"},{"categories":["Unreal","Game","GameDesign","GameDev","GameReview","PersonalWork","Dev","MeMe","Ramble","Other"],"content":" ","date":"2022-10-29","objectID":"/quickpost/:0:0","tags":null,"title":"查询精神状态","uri":"/quickpost/"}]