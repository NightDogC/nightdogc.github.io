[{"categories":["Ramble"],"content":"　我怎么这么菜？？？ 这是一个我几乎每天都会问自己的问题。 自我每天都这么问自己的数年后的今天，我终于醒悟了过来，从这个问题出发思考到了另外一个问题——我怎么每天都要问我怎么这么菜？？？ 我想这可能和我年轻时沉迷音游有关吧。音游社群有很多经典的现象，而其中之一就是令无数玩家反感，但怎么也杜绝不了的——卖弱现象，具体来说，在音游社群，从入门选手到顶级大佬，几乎每个水平阶段的人都会有人在说： 我怎么这么菜？？？ 这在音游社群中可不是什么谦虚的美德，反而是被很多社群禁止的一件事情。 那么，说自己菜有什么问题吗？ 音游这个玩意的性质是这样的，在达到一定水平，差不多是足够让路人看的眼花缭乱的水平后，音游玩家们会迎接他们音游生涯中最可怕的事物没有之一——瓶颈。达到瓶颈以后，音游玩家们会发现自己的水平提升速度会骤降，甚至停滞不前，而他们却发现技术比他们好的大佬们随手就能打出对他们来说不可理喻的成绩。 所以这就是卖弱的原因了吗？不是，或者说，光是这点还不够。音游还有另外一个性质，那就是其实音游的游戏逻辑很简单——分析你看到的谱面，并在最正确的时机按下正确的键/点击或滑动正确的地方。这就决定了一个在水平阶段高一档的人不论如何就是能吊打水平阶段低一档的人，没有任何运气、队友……等等因素，这点和早期的rts有点像。 虽然如此，但遇到第一个瓶颈期后，尽管进步会变得艰难，但只要稍微努努力还是能够突破的。现在让我们恭喜这位音游玩家达到了下一个技术水平，然后他就会发现，自己并不是走上了一条康庄大道，而是下一个更难的瓶颈就在不远处等着他——也就是说，在音游玩家享受到短短一段时间的进步的快感后，另一个进步速度比以前更慢、更容易停滞的日子将会伴随音游玩家更长的日子。 至此，音游玩家终于发现了一件事，自己不论突破了多少瓶颈，总会有突破了更多瓶颈的大佬吊打他，哪怕他已经能吊打很多很多水平不如他的玩家，而且更令他恐慌的是，自己当前的瓶颈期也不知道猴年马月能够突破，更令人绝望的是，也许一辈子也不能突破了。 说实话，很多游戏，甚至不只是游戏，而是世上大多数有挑战性的事物大多都是有这么一个规律的，但正如之前所说的，音游的底层逻辑是如此简单→决定成绩的除了技术水平几乎没有其它因素→技术好哪怕一档的人就是能够吊打低一档的人1，这个逻辑链一旦结合这个规律，给人的挫败感是很强的，对于一些相对不那么自信的人来说，无可避免的会陷入到一个自我怀疑中——我为什么这么菜？？？ 说自己菜的人真的很菜吗？并不，他也许能吊打90%的人，但就是有10%的人能轻松把他虐的体无完肤，他也并没有“我是很菜但是90%的人连菜都不如”之类的潜台词，因为他是从那90%走过来的——在他的认知中，那90%的人只是还没有走他这么长的路而已，而他既然能到这里，就说明只要走完该走的路，那90%的人也是可以达到他的水平的，而他却完全对自己能否突破下一个瓶颈期没有底。 所以只要把目光放广一点——吊打95%的人的人也是这么看吊打90%的人的人的，吊打99%的人的人也是这么看吊打95%的人的人的。别人能走到的地方，尽管不知道对你来说要花多久，但是只要在走，那一定是能走到的。 其实音游老狗们也对此也稍微有点数，但卖弱这事给水平稍低一些的人听起来是不那么舒服，这也是为什么这种行为被音游群体社群建议禁止的重要原因。 但都是一条音游老狗了，卖弱的各中原因会不明白吗。我当年虽然可耻地卖了不少弱，但对于我来说，我所希望的不是一句肯定“是的你个菜狗”，也不是一句否定“巨巨卖弱真不要脸”，而是希望一个事实能被确认——“菜就多练”——这是音游社群里最为正确，深得人心，脍炙人口，亘古不变，吊打一切的真理。尽管如此，但每当开始自我怀疑的时候，也不免会怀疑这条真理，而如果有人能跟我确认这真理真的是对的，对我来说是一个莫大的慰藉。 所以，时至今日，我并不打算停止每天问自己我为什么这么菜，因为哪怕是没有回应，我也要自己跟自己确认一遍这个最为正确，深得人心，脍炙人口，亘古不变，吊打一切的真理： 所谓个人差在我这看来不算，无非是细分的技术水平档次 ↩︎ ","date":"2022-11-10","objectID":"/posts/%E6%9D%82%E8%B0%88%E7%B3%BB%E5%88%97%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%8F%9C/:0:0","tags":["杂谈","音游","发病"],"title":"【杂谈系列】我为什么这么菜？？？","uri":"/posts/%E6%9D%82%E8%B0%88%E7%B3%BB%E5%88%97%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%8F%9C/"},{"categories":["Unreal"],"content":"\r警告\r这是一个非计算机背景虚幻入门人员的个人探索，仅记录个人学习时想法和思考过程用，可能会看到各种奇奇怪怪的错误和“这不理所应当知道的知识？”，十分不建议参考。\r","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:0:0","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"综述 保存游戏，可以说是一个游戏中最重要的功能之一。根据虚幻官方文档的说法，保存游戏在游戏开发的早期就应该被设计出来： Every game needs to come up with a carefully thought out save game management plan early in the game’s development. 这点在做自己个人作品的时候就吃了亏，把保存游戏放到了最后实现，存还是能存，不过也就是在一个一本道流程里保存一下当前关卡id而已，好在作品简单，整体影响不大。 这么一个重要的功能，虚幻已经帮我们实现好了一套使用序列化的保存游戏功能USaveGame，如果在网上搜索虚幻保存游戏，无外乎都是教你如何调用USaveGame的API，但问题来了（也可能是我搜索能力还不够），光是调用API还不够，如何去设计一个游戏的保存功能呢？ 大部分教程显然做得不够好，甚至有为了演示API直接把API调用写在Character类里的，因为他要存Character的HP数据。这里实际上会有两个问题，一是这么做本事其实是没问题的，但考虑到OO，Character在一个游戏里大概率不是上帝，拥有“保存”这种“能力”不太合适，我们需要一个设计来支持较大项目的保存。而第二个问题，面对一些中型以上的游戏，我们希望能保存各种各样的东西：敌人打到一半时它的状态、解谜过程中关卡的进度、玩家做任务的进度、甚至整个世界的进度等等，而不是保存玩家本身的状态就行了。 关于第二个问题，虚幻其实也有招，一是所有的UObject都继承了Serialize()支持序列化，二是虚幻在反射系统中提供了一个SaveGame标识符，这使得可以在UObject序列化的时候，有选择地将标识了SaveGame的属性进行保存，详细操作教程看Helo老师这篇即可： UE4/UE5中保存游戏的基础知识 —— Basics about SaveGame in UE4/UE5 那么回到第一个问题，有了这套东西，以我目前的水平来说的一个想法是，可不可以设计一个组件或者接口，组合或接入想要保存的重要Actor，然后通过一个子系统进行管理？ 但是先别急，对目前的我来说，胡乱进行设计不可取。事实上，保存功能不只是游戏，下至notepad，上至操作系统，undo和redo功能可太常见了，因此是有一个专门为此的设计模式的：C++设计模式——备忘录模式(Memento Pattern) 那么，结合大钊老师InsideUE的说法，USaveGame基本就是这个Memento了，剩下的就难以界定了，GameInstance、GameModeBase、各种State类、或者做一个SaveGameSubsystem去做剩下的事好像也都还行，毕竟虚幻直接为我们提供了CreateSaveGameObject、SaveGameToSlot、LoadGameFromSlot等等API，但为了尽可能地符合单一职责原则，也为了封装保存的数据，我们肯定还是希望专门有一个东西能够来负责这件事，这样来说，或许Subsystem确实是个不错的选择。 对于第二个问题，对于具体实现来说，光空想设计也不够，对于实现细节的处理也是有必要进行一番研究的，所以到了该进行项目参考的时候了！在众多不错的项目中，Tomlooman老师的ActionRoguelike的思路一眼看上去和我刚才的想法类似，可以看看他的具体实现。 首先会通读一遍代码，把实现中的要注意的要点都分析一下，这部分会占较大篇幅，然后对其进行一下总结，分析一下设计。 项目链接在此：Tomlooman老师的ActionRoguelike，他还贴心的写了一篇教程：Unreal Engine C++ Save System (SaveGame) ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:0","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"保存Actor的准备工作：接口和数据类型 在该项目中，对于想要保存的Actor接入了一个 GameplayInterface 接口，并在其中声明了OnActorLoaded() 注意\r这个接口是Tomlooman老师复用的一个接口，里面的其余函数声明和保存无关。 在自己实践时，尽量提供纯粹为了保存使用的接口，并给予接口正确的命名。 在这里使用接口的一个好处是，既可以对需要保存的Actor进行标记，又可以通过 OnActorLoaded() 去实现一些加载后的逻辑。当然，这部分逻辑在BeginPlay()里写也是一样的，只要确保你能在Actor的BeginPlay()调用之前加载好数据。 然后是用于保存数据的Struct： USTRUCT() struct FActorSaveData { GENERATED_BODY() public: /* Identifier for which Actor this belongs to */ UPROPERTY() FName ActorName; /* For movable Actors, keep location,rotation,scale. */ UPROPERTY() FTransform Transform; /* Contains all 'SaveGame' marked variables of the Actor */ UPROPERTY() TArray\u003cuint8\u003e ByteData; }; 注释很明白，但有两个可以思考的地方。 对于FTransform属性，为何要单独拎出来，这个会在后面体现出来 使用ActorName来标记，没有什么问题，只是后续看到TomLooman老师又点出也可以考虑使用FGuid来标记，对于runtime生成的Actor更有效，以及也可以有更多的解决方案 对于需要存储的Actor，将变量转换为二进制并保存 其实这部分看刚才提到的这个也差不多：UE4/UE5中保存游戏的基础知识 —— Basics about SaveGame in UE4/UE5 但还是做一下笔记： 使用 FMemoryWriter 和 FObjectAndNameAsStringProxyArchive （都继承自 FArchive ）能够将变量转换为二进制 然后就是源码了： void USSaveGameSubsystem::WriteSaveGame() { // Clear arrays, may contain data from previously loaded SaveGame CurrentSaveGame-\u003eSavedPlayers.Empty(); CurrentSaveGame-\u003eSavedActors.Empty(); AGameStateBase* GS = GetWorld()-\u003eGetGameState(); if (GS == nullptr) { // Warn about failure to save? return; } // Iterate all player states, we don't have proper ID to match yet (requires Steam or EOS) for (int32 i = 0; i \u003c GS-\u003ePlayerArray.Num(); i++) { ASPlayerState* PS = Cast\u003cASPlayerState\u003e(GS-\u003ePlayerArray[i]); if (PS) { PS-\u003eSavePlayerState(CurrentSaveGame); break; // single player only at this point } } // Iterate the entire world of actors for (FActorIterator It(GetWorld()); It; ++It) { AActor* Actor = *It; // Only interested in our 'gameplay actors', skip actors that are being destroyed // Note: You might instead use a dedicated SavableObject interface for Actors you want to save instead of re-using GameplayInterface if (!IsValid(Actor) || !Actor-\u003eImplements\u003cUSGameplayInterface\u003e()) { continue; } FActorSaveData ActorData; ActorData.ActorName = Actor-\u003eGetFName(); ActorData.Transform = Actor-\u003eGetActorTransform(); // Pass the array to fill with data from Actor FMemoryWriter MemWriter(ActorData.ByteData); FObjectAndNameAsStringProxyArchive Ar(MemWriter, true); // Find only variables with UPROPERTY(SaveGame) Ar.ArIsSaveGame = true; // Converts Actor's SaveGame UPROPERTIES into binary array Actor-\u003eSerialize(Ar); // Here CurrentSaveGame is a member variable of type USSaveGame* CurrentSaveGame-\u003eSavedActors.Add(ActorData); } UGameplayStatics::SaveGameToSlot(CurrentSaveGame, CurrentSlotName, 0); OnSaveGameWritten.Broadcast(CurrentSaveGame); } 具体实现方法和UGameplayStatics内提供的保存相关API的做法差不多，但是注意到仍然在最后一步调用了Unreal的API，观察Unreal源码可知，SaveGameToSlot还会执行一遍序列化，然后执行存储到Slot、写入磁盘的逻辑，在这里是为了照顾还没有序列化的PlayerState的各种PROPERTY以及ActorName、FTransform这两个PROPERTY。 如果你打算不执行两次序列化，而是直接手动把要存的东西全都序列化先，那么可以考虑直接复制或修改Unreal的这些源码并针对自己的定制化需求做出改动： bool UGameplayStatics::SaveDataToSlot(const TArray\u003cuint8\u003e\u0026 InSaveData, const FString\u0026 SlotName, const int32 UserIndex) { ISaveGameSystem* SaveSystem = IPlatformFeaturesModule::Get().GetSaveGameSystem(); if (SaveSystem \u0026\u0026 InSaveData.Num() \u003e 0 \u0026\u0026 SlotName.Len() \u003e 0) { // Stuff that data into the save system with the desired file name return SaveSystem-\u003eSaveGame(false, *SlotName, UserIndex, InSaveData); } return false; } virtual bool SaveGame(bool bAttemptToUseUI, const TCHAR* Name, const int32 UserIndex, const TArray\u003cuint8\u003e\u0026 Data) override { return FFileHelper::SaveArrayToFile(Data, *GetSaveGamePath(Name)); } 注意，这意味着失去了利用ActorName或者FGuid作为标记的功能，所以在加载的时候，如何确定反序列化时所对应的那个Actor？如何处理一些在Actor加载时的逻辑（比如SetTransform）？可能剖析完引擎源码这个问题就能轻松回答了，目前我的水平而言，只能改改代码试一试看看一些想法处理行不行得通了，考虑加入有生之年系列 甚至如果你不需要Slot，自行做一些判断后手动通过FFileHelper::SaveArrayToFile(Data, *SavePath) 保存到文件，通过 FFileHelper::LoadFileToArray(Data, *SavePath) 从文件加载即可 对了，不用特意去记住序列化的写法，明白FobjectAndNameAsStringProxyArchive和两个继承自FArchive的类，对于使用序列化来说基本够用了，因为Unreal帮你注释好了都： /** * Implements a proxy archive that serializes UObjects and FNames as string","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:1","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"保存PlayerData 之前说过，对于PlayerState单独拎出来实现是有一定道理的，保存PlayerData的部分和正常使用USaveGame基本没有什么区别 但是还是有一些细节，拿出源码来看看： void ASPlayerState::SavePlayerState_Implementation(USSaveGame* SaveObject) { if (SaveObject) { // Gather all relevant data for player FPlayerSaveData SaveData; SaveData.Credits = Credits; SaveData.PersonalRecordTime = PersonalRecordTime; // Stored as FString for simplicity (original Steam ID is uint64) SaveData.PlayerID = GetUniqueId().ToString(); // May not be alive while we save if (APawn* MyPawn = GetPawn()) { SaveData.Location = MyPawn-\u003eGetActorLocation(); SaveData.Rotation = MyPawn-\u003eGetActorRotation(); SaveData.bResumeAtTransform = true; } SaveObject-\u003eSavedPlayers.Add(SaveData); } } 首先当然地，保存的方法写在了PlayerState里（加载也是） 其次，注意PlayerID和玩家死亡的情况的处理 然后关于这个函数名的_Implementation后缀（以及函数有标识符 BlueprintNativeEvent ），我猜可能是老师上课要在蓝图里演示？我也没开始看课，感觉理论上是不需要的 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:2","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"读取PlayerData void ASPlayerState::LoadPlayerState_Implementation(USSaveGame* SaveObject) { if (SaveObject) { FPlayerSaveData* FoundData = SaveObject-\u003eGetPlayerData(this); if (FoundData) { //Credits = SaveObject-\u003eCredits; // Makes sure we trigger credits changed event AddCredits(FoundData-\u003eCredits); PersonalRecordTime = FoundData-\u003ePersonalRecordTime; } else { UE_LOG(LogTemp, Warning, TEXT(\"Could not find SaveGame data for player id '%i'.\"), GetPlayerId()); } } } 那么，LoadPlayerState是怎么调用的呢，以及，好像没有看到设置位置信息的逻辑？ 首先，调用加载的逻辑理论上写在很多地方都可以，比如加载关卡时，PS初始化时，等等，但其实这里有一个小细节，先看源码： 我们找到了在这里有一个调用： void USSaveGameSubsystem::HandleStartingNewPlayer(AController* NewPlayer) { ASPlayerState* PS = NewPlayer-\u003eGetPlayerState\u003cASPlayerState\u003e(); if (ensure(PS)) { PS-\u003eLoadPlayerState(CurrentSaveGame); } } 这显然不是终点，我们继续翻： void ASGameModeBase::HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer) { // Calling Before Super:: so we set variables before 'beginplayingstate' is called in PlayerController (which is where we instantiate UI) USSaveGameSubsystem* SG = GetGameInstance()-\u003eGetSubsystem\u003cUSSaveGameSubsystem\u003e(); SG-\u003eHandleStartingNewPlayer(NewPlayer); Super::HandleStartingNewPlayer_Implementation(NewPlayer); // Now we're ready to override spawn location // Alternatively we could override core spawn location to use store locations immediately (skipping the whole 'find player start' logic) SG-\u003eOverrideSpawnTransform(NewPlayer); } 到了这里，发现是对GameMode里生成Player的逻辑部分进行了重载，并且拆分成了两部分（注意调用Subsystem的逻辑放在了 Super::HandleStartingNewPlayer_Implementation() 之前） 具体这么做的原因观察注释可知，由于在BeginPlayingState（PlayerController类中的方法）有初始化UI的逻辑，且会在 Super::HandleStartingNewPlayer_Implementation() 中使用，所以写在这之前便可以在UI加载之前就获取到变量信息，也就可以确保UI显示正确的信息了 这也是C++的优势所在，如果在蓝图中想做同样的处理可能会很复杂（但是也有简单的方法，比如直接DelayNextTick一下，但是不保证不出其他问题） 写到这突然想写一篇GI、Level、World、GM、GS、PC、PS、Pawn在初始化各种加载和函数调用顺序分析，已加入有生之年豪华套餐系列 还是回过来看加载PlayerState吧，在PlayerState全部加载完毕后，也就可以开始调用Subsystem里写好的设置位置信息的逻辑了： bool USSaveGameSubsystem::OverrideSpawnTransform(AController* NewPlayer) { if (!IsValid(NewPlayer)) { return false; } APlayerState* PS = NewPlayer-\u003eGetPlayerState\u003cAPlayerState\u003e(); if (PS == nullptr) { return false; } if (APawn* MyPawn = PS-\u003eGetPawn()) { FPlayerSaveData* FoundData = CurrentSaveGame-\u003eGetPlayerData(PS); if (FoundData \u0026\u0026 FoundData-\u003ebResumeAtTransform) { MyPawn-\u003eSetActorLocation(FoundData-\u003eLocation); MyPawn-\u003eSetActorRotation(FoundData-\u003eRotation); // PlayerState owner is a (Player)Controller AController* PC = Cast\u003cAController\u003e(PS-\u003eGetOwner()); // Set control rotation to change camera direction, setting Pawn rotation is not enough PC-\u003eSetControlRotation(FoundData-\u003eRotation); return true; } } return false; } 注意点是这是一个重载的逻辑，也就是说不要忘了PlayerController里面的 SetControlRotation() 最后还有一点，已经两次看到 GetPlayerData(APlayerState*) 方法而没有细说了，其实很自然地能想到我们还有一个东西没有处理——PlayerID，那想必处理这部分的逻辑就是在这了： FPlayerSaveData* USSaveGame::GetPlayerData(APlayerState* PlayerState) { if (PlayerState == nullptr) { return nullptr; } // Will not give unique ID while PIE so we skip that step while testing in editor. // UObjects don't have access to UWorld, so we grab it via PlayerState instead if (PlayerState-\u003eGetWorld()-\u003eIsPlayInEditor()) { UE_LOG(LogTemp, Log, TEXT(\"During PIE we cannot use PlayerID to retrieve Saved Player data. Using first entry in array if available.\")); if (SavedPlayers.IsValidIndex(0)) { return \u0026SavedPlayers[0]; } // No saved player data available return nullptr; } // Easiest way to deal with the different IDs is as FString (original Steam id is uint64) // Keep in mind that GetUniqueId() returns the online id, where GetUniqueID() is a function from UObject (very confusing...) FString PlayerID = PlayerState-\u003eGetUniqueId().ToString(); // Iterate the array and match by PlayerID (eg. unique ID provided by Steam) return SavedPlayers.FindByPredicate([\u0026](const FPlayerSaveData\u0026 Data) { return Data.PlayerID == PlayerID; }); } 基本上要注意的点都在注释里写着了，没什么要说的了 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:3","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"对需要加载的Actor，将二进制转为变量并加载 这次使用 FMemoryReader 便可以在调用Serialize()时将二进制读取为变量了 void USSaveGameSubsystem::LoadSaveGame(FString InSlotName /*= \"\"*/) { // Update slot name first if specified, otherwise keeps default name SetSlotName(InSlotName); if (UGameplayStatics::DoesSaveGameExist(CurrentSlotName, 0)) { CurrentSaveGame = Cast\u003cUSSaveGame\u003e(UGameplayStatics::LoadGameFromSlot(CurrentSlotName, 0)); if (CurrentSaveGame == nullptr) { UE_LOG(LogTemp, Warning, TEXT(\"Failed to load SaveGame Data.\")); return; } UE_LOG(LogTemp, Log, TEXT(\"Loaded SaveGame Data.\")); // Iterate the entire world of actors for (FActorIterator It(GetWorld()); It; ++It) { AActor* Actor = *It; // Only interested in our 'gameplay actors' if (!Actor-\u003eImplements\u003cUSGameplayInterface\u003e()) { continue; } for (FActorSaveData ActorData : CurrentSaveGame-\u003eSavedActors) { if (ActorData.ActorName == Actor-\u003eGetFName()) { Actor-\u003eSetActorTransform(ActorData.Transform); FMemoryReader MemReader(ActorData.ByteData); FObjectAndNameAsStringProxyArchive Ar(MemReader, true); Ar.ArIsSaveGame = true; // Convert binary array back into actor's variables Actor-\u003eSerialize(Ar); ISGameplayInterface::Execute_OnActorLoaded(Actor); break; } } } OnSaveGameLoaded.Broadcast(CurrentSaveGame); } else { CurrentSaveGame = Cast\u003cUSSaveGame\u003e(UGameplayStatics::CreateSaveGameObject(USSaveGame::StaticClass())); UE_LOG(LogTemp, Log, TEXT(\"Created New SaveGame Data.\")); } } 循环那一波反序列化如果算一次反序列化的话，注意到这里其实有两次反序列化 至于调用，可以在主关卡加载时调用，总之确保在Actor的BeginPlay()之前就反序列化好就行，遇到额外的关卡流的情况可能会复杂一些，由于项目中没有这种需求，所以直接在GameModeBase的 InitGame 的重载里调用了，这个函数在加载过程中的很早期就会被调用： void ASGameModeBase::InitGame(const FString\u0026 MapName, const FString\u0026 Options, FString\u0026 ErrorMessage) { Super::InitGame(MapName, Options, ErrorMessage); // (Save/Load logic moved into new SaveGameSubsystem) USSaveGameSubsystem* SG = GetGameInstance()-\u003eGetSubsystem\u003cUSSaveGameSubsystem\u003e(); // Optional slot name (Falls back to slot specified in SaveGameSettings class/INI otherwise) FString SelectedSaveSlot = UGameplayStatics::ParseOption(Options, \"SaveGame\"); SG-\u003eLoadSaveGame(SelectedSaveSlot); } 如果遇到一些额外情况需要处理，实现接口的函数或者写在Actor里BeginPlay里都是可选项 另外就是注意到这里： FString SelectedSaveSlot = UGameplayStatics::ParseOption(Options, \"SaveGame\"); ，从ini选项配置中读取特定SlotName，这个东西想来想去还是打算在用户配置相关内容里详述（加入有生之年套餐），目前我就先贴上源码吧： SSaveGameSettings.h #pragma once #include \"CoreMinimal.h\" #include \"Engine/DataTable.h\" #include \"Engine/DeveloperSettings.h\" #include \"SSaveGameSettings.generated.h\" class UDataTable; /** * */ UCLASS(Config=Game, defaultconfig, meta = (DisplayName=\"Save Game Settings\")) // 'defaultconfig' = \"Save object config only to Default INIs, never to local INIs.\" class ACTIONROGUELIKE_API USSaveGameSettings : public UDeveloperSettings { GENERATED_BODY() public: /* Default slot name if UI doesn't specify any */ UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category = \"General\") FString SaveSlotName; /* Soft path must be converted to asset before use */ UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category = \"General\", AdvancedDisplay) TSoftObjectPtr\u003cUDataTable\u003e DummyTablePath; USSaveGameSettings(); }; SSaveGameSettings.cpp #include \"SSaveGameSettings.h\" USSaveGameSettings::USSaveGameSettings() { // Default value while nothing is specified in the DefaultGame.ini SaveSlotName = \"SaveGame02\"; } 另外找到的ini文件里： [/Script/ActionRoguelike.SSaveGameSettings]\rSaveSlotName=SaveSlot04\rDummyTablePath=/Game/ActionRoguelike/Monsters/DT_Monsters.DT_Monsters 以及在蓝图里OpenLevel里该如何加载特定的SaveGame文件： ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:4","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"设计总结 其实总的看下来，大方向上的设计可以说没什么好说的了，得益于Unreal已经帮我们做好的USaveGame和Subsystem，基本上对于框架考虑的负担已经很小了，而有足够的理由时，也可以做出一些变化，比如本例中对于PlayerState的处理。 UML就先不画了，暂且文字总结一下： USSaveGameSubsystem：继承自UGameInstanceSubsystem，拥有和GameInstance一样的生命周期 拥有#属性： FString CurrentSlotName 和 USSaveGame CurrentSaveGame ，+单参数动态多播委托： OnSaveGameLoaded 和 OnSaveGameWritten 拥有+方法： void HandleStartingNewPlayer(AController*) 、 bool OverrideSpawnTransform(AController*) 、 void SetSlotName(FString) 、 void WriteSaveGame() 、 LoadSaveGame(FString) 和+重载的方法： Initialize(FSubsystemCollectionBase\u0026) 其中，WriteSaveGame 负责Actors和PlayerState的保存逻辑，可以在任何想要保存的地方调用，这个方法内部调用了PlayerState里的 SavePlayerState LoadSaveGame 负责Actors的加载逻辑，在GameMode里的 Init 里调用，确保在Actor的BeginPlay调用之前进行读取 HandleStartingNewPlayer 、 OverrideSpawnTransform 负责PlayerState的加载逻辑，在GameMode里重载的 HandleStartingNewPlayer 中调用 在GameMode里重载的 HandleStartingNewPlayer 中， HandleStartingNewPlayer 调用了PlayerState里的 LoadPlayerState，且在 Super::HandleStartingNewPlayer 之前，确保UI加载前已经完成读取，OverrideSpawnTransform 则是用于还原Pawn的位置信息 USSaveGame：继承自USaveGame，基本上是一个数据类 拥有+属性 TArray\u003cFPlayerSaveData\u003e SavedPlayers （声明为数组的好处是方便进行多人游戏的扩展）和 TArray\u003cFActorSaveData\u003e SavedActors 在 FActorSaveData 结构体中使用了 TArray\u003cuint8\u003e ByteData 以进行序列化保存Actor的变量 拥有+方法： FPlayerSaveData* GetPlayerData(APlayerState*) 来获取正确的Player的PlayerData，在Load PlayerState的流程中调用 PlayerState：拥有两个针对PlayerState进行保存和加载的方法 ISGameplayInterface：提供用于标记需要保存的Actor的接口，拥有方法 void OnActorLoaded() 可以看出，大体上两个类一个负责管理一个负责数据，依赖了PlayerState进行中转，管理类中的数据类实例不进行公开，是一个很标准的SaveGame设计，当然也有一些思考的地方，主要集中在对PlayerState的处理上，我在这里就先不说想法了，毕竟设计嘛，总归是先模仿了，后续慢慢加入自己的想法不断改进，我的水平既然还在模仿的地方，那就不必献丑了 ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:5","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"一些补充和提高篇的展望 事实上，这套保存系统并不算复杂，对于一些中大型项目，这个确实可以作为一个保存系统设计的起点，那么对于这套保存系统，还需要一些什么东西呢？ 首先，很明显地以现在组件化开发的模式，光保存Actor是不够的，还有各种ActorComponent需要保存，甚至也不知道以后虚幻会不会大张旗鼓地全面使用ECS模式，那整个实现又不一样了。 其次是对于Destroyed的Actor，通过这样的方法是保存不到的。当然想实现也行，不过我现在的考虑可能还不够成熟，就不展开说了（第一步是用参考 PlayerSaveData 里使用成员变量 bResumeAtTransform 做标记的方法，然后hmmmmmmmmmm，balabala，最后加载时调用一下Destroy，就可以了） 除此之外，虚幻4示例项目ActionRPG的URPGSaveGame立重载了USaveGame的Serialize()，使得支持不同版本的存档，对于有更新需求的游戏来说，是个不错的参考。 另外，如果实现联机，有关获取PlayerState的问题的参考如下： 客户端获取Actor PlayerController的途径有Server SetOwner-\u003eClient GetOwner，但不唯一。通过在Server记录PlayerController准确的Index然后传给Client，让Client使用GetPlayerController（Index）能获取到正确的PlayerController；使用PlayerState，GetPlayerStatus-\u003eGetPlayerID-\u003eGetPlayerControllerFromID亦可得到正确的PlayerController。 From：UE4笔记8：多人情况下获取玩家控制器的问题 最后，对于额外的关卡流保存和加载，可以参考 Steve’s Library（很强） 理论上，这些应该都会加入提高篇，而提高篇则会加入有生之年套餐！ ","date":"2022-11-09","objectID":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/:1:6","tags":["Unreal","个人探索","保存游戏","开发设计","序列化","项目源码解读","内含有生之年","基础"],"title":"【个人探索】研究一下保存游戏的设计与实现细节（基础篇）","uri":"/posts/%E4%B8%AA%E4%BA%BA%E6%8E%A2%E7%B4%A2%E7%A0%94%E7%A9%B6%E4%B8%80%E4%B8%8B%E4%BF%9D%E5%AD%98%E6%B8%B8%E6%88%8F/"},{"categories":["Unreal"],"content":"本次笔记的课程为 大钊-虚幻C++的进阶之路 里面简单介绍了一下UnrealC++的学习路径、Module-UBT-C#相关、反射-UHT相关、对象类型相关（顺便自己摘抄了一点软引用的东西） 由于内容较多，体系完整，基本上属于是摘抄PTT和发言，方便以后随时回看，后续会根据此篇写一篇针对个人的学习路径 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:0:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"什么是虚幻C++ 扎实的标准C++基础能力 采用C++编写游戏逻辑 适应虚幻引擎的底层C++框架 Module配置和插件的使用 UBT和UHT（编译工具、头文件生成工具） 掌握Core模块的C++库：FString、TArray、UE_LOG等 熟悉了解掌握CoreUObject：宏、GC、序列化等 熟悉C++和BP交互的方式 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:1:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"学会虚幻C++的标志是什么？ 懂得解决各种编译链接错误（常是因为Module配置出错） 懂得一些常见的编写套路（CreateDefaultSubobject、UPROPERTY的标识符） 理解UObject的内存管理机制，不会经常造成内存崩溃 可以在源码里找到自己想要的代码块 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:1:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"为什么虚幻要开放C++来编写Gameplay 更高端，更需要压榨机能 更底层，更有能力优化性能 更大项目，强类型语言更有能力管理项目 更开放，更有灵活的定制型 更易迭代，不需要时时更新接口层 更相信开发者，进入了C++这个自由的领域，就得有自我负责的觉悟 方便扩展功能，直达引擎的底层结构 更好的性能，性能热点的优化 方便调试引擎，理解引擎流程和修复bug 大项目必须有某种Hold得住的语言 没法实现定制化的需求 游戏逻辑只能达到有限的优化 项目大到一定程度就很难管理 最后一点，可以更好地学习游戏引擎知识，也可以理解别人写的插件 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:2:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"虚幻C++与蓝图？ 官方文档中游详细介绍虚幻C++与蓝图的优劣，它们都是工具，需要学的和做的事利用工具的优势 一般而言，20%核心用C++写，80%表层使用蓝图，但也不是绝对的，根据项目类型和个人技能而定 大概的规则： 偏向引擎底层，偏向性能热点，偏向稳定的，采用C++ 偏向表现层，偏向经常操作的，偏向多变的，采用蓝图 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:2:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"虚幻C++有哪些要点 C++的基础一定需要巩固（推荐书目InsideC++ObjectModel），Unreal使用C++11，所以需要学到能够看懂别人怎么用这些东西： TArray、TSet、TMap等各种容器 FString、FName、FText的操作互转 TSharedPtr、TSharedRef、TWeakPtr等各种智能指针 有能力理解Delegate、TAttribute、TSubclassOf的机制和用法 多看看设计模式，才能更好理解Unreal代码的结构 多线程的知识，才能用好FRunnable等多线程同步 人脑展开宏的能力（脑子里要能堆栈） Core，即Engine/Source/Runtime/Core部分的内容 Gameplay部分，详见InsideUE Module、UBT、C# 反射、UHT CoreUObject（也在Engine/Source/Runtime/）、GC 常见套路 各模块的\"地方习俗\"，专攻时学习 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"Gameplay部分 Gameplay的C++编写 Actor的创建，组装Component，BeginPlay，Tick，碰撞输入事件绑定 引擎Gameplay对象的继承组织使用 UObject自定义对象的组织管理（根据逻辑而定）（NewObject、CreateDefaultSubobject、SpawnActor） 引擎数据对象的使用，Config，DataTable 功能模块的C++层级编写（UMG、AI、动画等），注意有机结合 学习Egine/Class/GameFramework模块代码 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"Module、UBT、C# Unreal使用C#来管理编译流程，深入到模块链接的时候就会接触到 C++以一个cpp文件为一个编译单元，编译阶段时，根据include预编译指令，将包含的文件复制粘贴进来，那么1.该上哪里去找这些文件，该如何定位它们；2.然后在LINK阶段，需要怎么链接dll 为了解决这两个问题，中间需要很多逻辑与配置，比如模块与模块之间要怎样做，编辑器情况下要怎么样，等等 UE4支持众多平台，包括Windows，IOS，Android等，因此UE4为了方便你配置各个平台的参数和编译选项，简化编译流程,UE4实现了自己的一套编译系统，否则我们就得接受各个平台再单独配置一套项目之苦了。\u000b这套工具的编译流程结果，简单来说，就是你在VS里的运行，背后会运行UE4的一些命令行工具来完成编译，其他最重要的两个组件： UnrealBuildTool（UBT，C#）：UE4的自定义工具，来编译UE4的逐个模块并处理依赖等。我们编写的Target.cs，Build.cs都是为这个工具服务的。 UnrealHeaderTool （UHT，C++）：UE4的C++代码解析生成工具，我们在代码里写的那些宏UCLASS等和#include “*.generated.h\"都为UHT提供了信息来生成相应的C++反射代码。\u000b一般来说，UBT会先调用UHT会先负责解析一遍C++代码，生成相应其他代码。然后开始调用平台特定的编译工具(VisualStudio,LLVM)来编译各个模块。最后启动Editor或者是Game. 优点：C#足够易读，C#足够灵活定制逻辑，C#可以动态编译，方便搜集信息，C#足够强大可以调用其他工具(如调用Git确定哪里被修改了，调用VS的编译工具等等） 缺点：C#和C++混合经常搞得有些人糊涂，C++项目里混进C#没有智能提示不够友好 解决：常见的错误都是这两者报出的，记住常用用法就行了，有问题再查。 悄悄说，UBT用的是NMake build system 所以常见的错误一般都是宏写错了、.h位置不对（UHT报出来的）、编译错误（UBT报出来的） 学会链接模块，项目和插件可包含多个模块 UBT调用UHT生成代码，然后调用MSBuild编译代码 Build.cs是重点（ModuleRules.cs） 点下Build后UBT做了哪些事情 首先UBT会去搜集目录里面的cs文件，获得配置信息 调用UHT，分析.cpp文件，根据include预编译指令和Unreal宏生成.generated.h文件（Intermediate路径下），此时如果宏没写对，这一步UHT就会报错 UBT调用MSBuild，把.cpp文件和.generated.h合到一起编译一下 ModuleRules.cs 模块链接 PublicDependencyModuleNames： public链接的模块名称，最常用 在自己的public和private里包含对方的public PrivateDependencyModuleNames： private链接的模块名称，只引用不暴露 在private里包含对方的public，不扩充自己的public DynamicallyLoadedModuleNames: 动态链接的模块名称，在runtime被ModuleManager加载，保证先编译 所谓自己的public和private就是Source文件夹里常有的Public和Private，在引擎源码部分里也可以看到 头文件include PublicIncludePaths： public包含的路径 定义自己向外暴露的public，默认”Public”和”Classes” PrivateIncludePaths： private包含的路径 定义自己的private，给自己内部引用，默认“Private”，一般用来定义Private子目录。当然也可以路径包含Private/Sub，但这是一种方便方式。 头文件include 模块 PublicIncludePathModuleNames： public包含的模块名称，可以只写模块名称 PrivateIncludePathModuleNames： private包含的模块名称，可以只写模块名称 用途： 只包含对方模块的.h文件，比如模板，虽然挺少见 更多是动态链接，先包含头文件信息，之后加载 第三方库链接 PublicAdditionalLibraries： 引用的第三方lib路径 PublicSystemLibraryPaths ：引用的系统lib路径，其实也只是lib，只不过对于一些更“系统”底层的库用这个名字更友好一些 PublicDelayLoadDLLs：延迟加载的dll 具体怎么用，可以在引擎源码里去找找，比如AlembicLib.build.cs 其它常用 PublicDefinitions + PrivateDefinitions ： 额外的其他C++宏定义 Target： 得到当前的编译目标信息 Platform：平台，Win64，Android，IOS Configuration：配置， Debug， Development， Shipping public和private包含 做的游戏的项目其实无所谓，但是如果涉及到给别人用的模块或者插件就需要注意，应当只给出调用，而不要把实现暴露出去 还是图比较直观： 如果A模块public包含B模块，那么A模块中的public和private中的文件都可以include模块B的文件 如果A模块private包含B模块，那么A模块中的public中的文件不能include模块B的文件，只有private中的文件可以include模块B的文件 所以什么时候用public包含，什么时候用private包含？ 当你写的这个模块所包含的模块也希望给别人使用时，public包含 当你写的这个模块所包含的模块不希望暴露给别人时，想让暴露的接口干净一点，private包含 总结一下，include头文件找不到的情况下，应当看看你包含的模块在Build.cs里是否有相应配置，.cpp文件include不到，看看你包含的模块在Build.cs里是否是private包含 另外，一般情况下而言，Class也属于Public。 所以，如果想要include一个文件，那么： 在Class/Public/Private路径前面的一个是其模块名，需要在Build.cs里包含 在Class/Public/Private路径后面的所有是你应该写在include的东西 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:2","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"反射、UHT 理解.generated.h和gen.cpp 理解MODULENAME_API的含义（常见的犯错地方），这个是用来做dll互相导出的 掌握使用这些宏的含义和用法（反射的重要标记，在ObjectMarcos.h里可以看到） UCLASS USTRUCT UENUM UPROPERTY UFUNCTION UINTERFACE GENERATED_BODY() 清晰理解类型和对象之间的关系：ClassReference Vs ObjectReference Object Reference，是一个对Actor实例的引用，即其引用的类被实例化，被引用的资源也会被实例化，被引用的资源都会加载到内存中 Class Reference，在C++中就是TSubclassOf\u003c\u003e，对一个UObject的class的引用，用处和TSubclassOf相同，即常用于创建对象和让美术师、设计师引用资源 其实还有SoftClassReference和SoftObjectReference，这两个是指内部存储的资源路径，使用时加入还未被加载则先加载再使用，还可以用作跨关卡的Actor的引用 SoftObjectReference等价于C++中的TSoftObjectPtr，引用了这个资源的路径，当无需此资源时，无需将资源加载到内存中，只要保存一个资源路径（实际上存了一个FSoftObjectPath结构体）就好，通过这个可以实现异步资源加载 SoftClassReference，等价于C++中的TSoftClassPtr，与TSoftObjectPtr不同的是，TSoftClassPtr返回的是这个UObject对应的UClass* 总的来说，TSoftClassPtr侧重于描述UObject的Class，一些配置扩展的class就可以用这个，比如伤害类型等，而TSoftObjectClass则引用一些 具体原因： 而TSoftObjectPtr侧重于描述某一类资源，比如静态模型、动态模型、数据表格等 对于FSoftObjectPath，可以用元数据标识符 meta = (AllowedClassed=\"Material,StaticMesh\") 来限定某种特定的资源 但，该元数据只能筛选现有资源类型，当需要自定义继承UObject的类想用这个就没办法了，所以这时候就需要FSoftClassPath，并说明元数据标识符： meta = (MetaClass = \"MyActor\") 关于资源加载也是一个大篇章，这里先简单介绍一下这两个软引用 理解UClass*、UScriptStruct*、UField*、UFunction*、UProperty* 掌握通过反射遍历对象属性、读取写入，较为常见 掌握通过反射遍历对象函数并调用的方式，用的少一点 通过对象找类型，通过类型找对象 理解\"对象用类型描述，类型本身又是对象”（C#表示确实） ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:3","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"CoreUObject GC、内存管理：理解对象之间的关系，标记清扫，有一些对象是Root 简单来说，没被引用的对象会被清扫，想要既不被引用又不被清扫，就需要添加到Root（这就是在Unreal里自己强行写单例模式会犯的各种错之一，不添加Root被当垃圾回收了） 注意只有UPROPERTY标记的才参加GC，因为要根据UPROERPTY来分析引用链，不写UPROPERTY的话请自己处理 注意FMyStruct和UObject的混用，FGCObject::AddReferencedObjects 不要在Unreal里写new和delete，这俩被Unreal重载了 CDO（ClassDefaultObject）：理解类型和对象实例化、模板 理解ClassDefaults作为模板的作用 理解CDO在序列化中的意义和作用 通过UClass::GetDefaultObject来获得CDO信息 Package：理解对象的相互组织方式 对象可以包含子对象 序列化时，把一系列对象用一个对象包起来，这个对象叫做包 Package也可以互相引用，根据对象的相对路径 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:4","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"套路 UHT的套路：宏 模块链接的套路：几个常用属性.AddRange Actor创建的套路： ConstructorHelpers（这属于hardcode资产，不太常用其实） CreateDefaultSubobject 设置一堆属性 SetupAttachment Gameplay继承的套路： 尽量别在关卡蓝图里写逻辑 想要结构良好，尽量遵循引擎结构，各司其事 GI、GM、GS、PC、Pawn、PS全都继承一波带走 遵循推荐结构，会发现后期扩展和支持联机有天然优势 C++和BP交互的套路： 各种标识符的使用 C++定义基类写逻辑，蓝图继承进行配置时钟推荐易扩展高性能的方式 蓝图函数库是个好东西 事件绑定的套路： DELEGATE、MULTICAST_DELEGATE、EVENT、DYNAMIC Input：BindAxis、BindAction Collision：Hit、Overlap、AddDynamic Slate\u0026UMG Event：SLATE_EVENT(FOnClicked, OnClicked) FTimerManager 引擎常用方法的套路： Engine/Class/Kismet这个路径下有很多库，有很多好东西，都是做好了的实用的功能 GameplayStatics很常用，可以访问GamePlay的很多对象 UKismetSystemLibrary，系统目录等功能，LineTrace UKismetMathLibrary，数学 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:3:5","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"虚幻C++有哪些难点 C++基础 数据结构算法，操作系统多线程 数学基础：线性代数、向量矩阵、牛顿力学 游戏开发知识基础：渲染、动画、AI 项目开发经验：如何设计一个\"足够好\"的项目代码框架 记住知识要点：各种宏和API ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:4:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"如何学习虚幻虚幻C++ 学习从模仿开始，形成肌肉记忆，也知道了去哪里抄 模板项目，官方项目等 模仿引擎源码，最权威也最节俭，缺点是首先要找得到，然后要看得懂 模仿社区项目，或者搞到的其他人的插件，缺点是水平参差不齐，一般写的比较杂乱，不要被带沟里，建议多讨论交流 多看一些教程文章和视频 勇敢尝试动手改改 着手微调一些地方观察变化 遵循套路增加一些功能看能否做到 翻翻找找.h或相关地方是否有好用的接口 总结规律 总结你发现到观察到的概念，规律，规范，注意事项 用工具记录下来，在社区分享贡献 善于积累 弄个测试项目，用一个最小的场景用于测试你想理解的功能 有用的代码功能块，可以用插件或函数库封装起来，在项目之间复用，形成代码资产 对于概念，可以用思维导图来分析理解，理清关系和区别 尝试自己画流程图，能用图表示出来才说明理解透彻 玩具项目实践 如自己做一些独立游戏项目，大大有助于自己思考项目架构 用项目级实践来考验自己的掌握能力 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:5:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"其它的一些Tips 用插件来在项目间共享代码，动手编码前多想想 变量类型尽量的偏向抽象基类，比如UStaticMeshComponent（甚至UMeshComponent，万一以后想要换成SkeletonMesh呢）和UPrimitiveComponent（TriggerActor就是用ShapeComponent变量） Include尽量IWYU，include what you use，加快编译速度 善用C++前置声明，减少include依赖，加快编译 蓝图函数库是个很有用的宝库 C++代码里不要写数据配置！尝试数据驱动！C++-\u003eBP-\u003eDataTable 蓝图也是要做好设计模式功能划分的，才能更好的协作 再说一次，项目一开始就C++定义基类+蓝图继承，后面肯定会发现这很有先见之明！ 没有C++基类的蓝图类，也可以reparent基类，记得先备份！ 重构了C++基类名字，导致蓝图找不到父类？用CoreRedirects来修复（详见官方文档） 如果可以不改引擎，尽量不改！就算编译版引擎也可以通过UObject来打洞Hack，和C++奇技淫巧来访问private成员。 如果想好要改，在改动上下包上宏或注释标记，以后merge方便。 一切从GEngine开始：UEngine*GEngine; UGameEngine/UEditorEngine 从GEngine可以开始获得Worlds，游戏播放和编辑的场景也都是个world 获取游戏视口进行slate叠加或截图等 GEditor对做编辑器扩展很有用：UEditorEngine* GEditor; 可以获得当前选择Actor等有用信息 可以获得当前视口 可以调用编辑器功能 可以获得事件回调 编辑器也是个游戏，也都是各种UObject组成的，所以只要你能获取到正确的对象，就能为所欲为了！ NewObject的背后，基本上所有的对象都存放在对象池里，意味着你能获取到任何对象。 Actor里是可以runtime动态创建添加Component的，想想Spline，想想编辑器本质只是在跑的一个Game。 ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:6:0","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"源码剖析经验方法论 时空观 时：注重时间上的先后，观察函数的调用流程，事件的触发时机 空：注重数据的吞吐转换，观察信息的采集，数据的加工消化利用 有时要专注考察某一方面，有时要同时拥有两种脑袋 时空的交互，组成了有机的功能架构支撑，调度起资源，启动内循环，响应外部刺激 信息论 最小信息原则 = 依赖最少 = 越稳定 信息本质也是能量，只有掌握了足够的信息，才有足够能量实现某些功能 数据是信息，代码结构是信息，项目协作方式也是信息 从开始到结束 一开始有哪些东西？ 第一把点火的推力是什么？ 启动后自循环是那些推力？ 有哪些外部输入的刺激？ 向外部吐出了哪些数据？向外部施加了哪些力？ 最后剩下什么？ 保持谦逊但不迷信 首先怀疑是自己太傻，最后才觉得人家写的不够好。97.34%最终会发现是自己的问题。 觉得源码写得不够好，自己必须能切实的在充分理解问题区间的基础上指出错误并写出更好方案，否则没有资格批评！忌空谈！ 认识到引擎开发人员也是普通人，是人就会犯错。但大概率人家水平比自己高，小概率会疏忽。 认识到引擎是个历史悠久的大工程，里面充满了历史馈赠的遗产、包袱和迷雾。所以很多觉得不够好的原因是历史带来的，不应该过于苛责。 比起好奇心更应该保持耐心！ 常常会困惑这是干嘛的？ 常常会理解不了为什么这么做？有什么特殊的用意？ 数据用来用去，代码调来调去，感觉一团乱麻！ 调用链条太长，自己的脑容量堆栈不足以存储…… 所需的背景知识有欠缺…… 无人可问，孤军奋战…… 直面磅礴的源码库，深感自己的渺小！ 对引擎更新又激动又害怕，对自己一天只有24小时这个事实深感无力！ 承认自己是个凡人，余生只够掌握一小块知识，和自己妥协，从此虚心向别人请教，对别人的分享心存感激，为自己也能尽一份力分享而欣喜~ 工具越简单越好，专注核心内容，别浪费时间调整格式！ 放弃除了VS之外的源码阅读工具，额外的都是负担，间接一层就多了一层信息同步消耗。 放弃UML图系列工具，只取其思想，放弃其形式，对于上百个类来说，人类无法理解UML的哪怕各角度表达，更何况还得手调其格式排版，一半情况下每新加一个类都得调整一遍。 对于已经确定的内容，才需要画图来加深理解。别一边理解一边画图，90%时间在调整图排版。 我个人最后选择了思维导图，有不足，但足够简单可理解。 最后写文章，我用Markdown码字，Processon画流程图 调试过程： 开Debug配置编译源码，debug everything！编译选项说明见InsideUE基础概念一章 一边调试一边记录 在引擎源码内加debug输出，根据打印数据信息确定数据内容和先后 抓住主脉络，旁支情况记一下以后再收拾 技巧在于：找！顺藤摸瓜的找！ WidgetReflector定位代码块（Unreal菜单栏-Tools-Debug里面） VA 查找所有引用或调用 VS 字符串查找 Everything工具定位文件 开Debug断点查事件调用 功底体现在于：瞧的懂大概是咋回事 搬的技巧在： 能找到办法直接调用的就别拷贝代码 能否找到调用的代码路径的功底在于：能否事先理解各模块对象的组织关系，事先修行有必要 别在Runtime下想法子调用Editor的代码，不合法也费劲 找到目标代码块的：输入和输出，小心内部的依赖 自己嫁接过来的时候要想法子喂给足够的数据 如果是流程上插一脚的，想法子找到关键的“旋钮“ ","date":"2022-11-05","objectID":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/:6:1","tags":["Unreal","C++","笔记","学习路径","模块","软引用","资源加载"],"title":"【课堂笔记】大钊-虚幻Cpp的进阶之路","uri":"/posts/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%E5%A4%A7%E9%92%8A-%E8%99%9A%E5%B9%BBcpp%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"},{"categories":["Unreal"],"content":"【Unreal Nuggets】系列为记下来平时使用Unreal开发过程中的一些小Tips、小（骚）操作、以及一些临时去查的小特性小功能。 本篇主要为记录一些个人之前自己研究UE时用的比较少的一些蓝图流程控制节点、容器操作节点等等，在别的地方看见了会摘录到这里来。 使用多次以后也会相应地删除。 ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:0:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"蓝图连直线 讲道理默认那个扭曲的线条真的很丑（ ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:1:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"Gate Node ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:2:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"MultiGate Node ","date":"2022-11-05","objectID":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/:3:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【Unreal Nuggets】个人向蓝图拾遗","uri":"/posts/unreal-nuggets%E4%B8%AA%E4%BA%BA%E5%90%91%E8%93%9D%E5%9B%BE%E6%8B%BE%E9%81%97/"},{"categories":["Unreal"],"content":"工作上出了点问题，本质上是对软件工程和设计模式还不够熟悉。姑且先不论之后进一步系统性的学习，首先还是要解决一下目前工作的问题，因此这个笔记属于一个临阵磨枪的性质，不会有深入的剖析，而是强行为个人接下来的实践服务，故谨慎参考。 在这之前，无论如何首先要把大钊的InsideUE中的Gameplay篇章快速过一遍，后续会再对InsideUE进行精读：大钊 - InsideUE4 另，本篇参考教程如下： [英文直播]和Tom Looman一起开发C++游戏玩法框架(官方字幕) [中文直播]第26期 | 虚幻引擎GamePlay框架理解与应用 | Epic 大钊 马骥 ART0189 - 游戏开发工程 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:0:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ActorComponent： 组件是种能力 为Actor提供能力 能力一般跟业务逻辑无关 能力是跨游戏的 一个问题：如果尝试采用组件化开发，在该游戏中有不同的Actor都需要应用同样一份业务逻辑，但是该逻辑不一定能被其他游戏用上，该怎么办呢？ 目前个人的想法是添加接口，即如果一定要用到别的游戏，也不是不可以，去把接口实现了就行。 例： 通用耐久度设计： 新建DurabilityInterface，提供函数： ConsumeDurability(float AlternativeEnemyATK); QueryDurability(); 整合耐久度系统至SuperDurabilityComponent，继承自UActorComponent、IDurabilityInterface 声明变量float Durability、float DurabilityHarmMultiplier 实现QueryDurability() { return Durability; } 创建子类WeaponDurabilityComponent、ArmorDurabilityComponent、PropDurabilityComponent 从PropDurabilityComponent创建子类TimeRelatedPropDurabilityComponent、FrequencyRelatedPropDurabilityComponent 在PropDurabilityComponent以外的各个子类实现ConsumeDurability(float AlternativeEnemyATK) ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:1:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ALevelScriptActor（关卡蓝图）： 对于项目来说，大部分情况下在关卡蓝图里并不适合写功能，最多适合一些Demo，快速地做一些功能验证 适合一些关卡本身的触发机械互动，且多为表现相关内容，比如到某处触发一段Sequence 一些关卡中机关的触发，虽然看似和关卡本身相关，但机关的触发本身在别的关卡中也需要有，因此触发机关的逻辑还是写在机关Actor本身上为好 Actor本身也是为了实现跨关卡的能力。 按我个人目前的理解，某个关卡中某个区域或整个关卡的的重力等这样的一些关卡配置逻辑或许也可以写进关卡蓝图中，但还是尽量谨慎吧。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:2:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"APawn、APlayerController和APlayerState Pawn相比Actor，足够复杂 Pawn、State、Controller一体，集成了MVC Pawn里面也要拒绝写入太过于庞大的逻辑和数据，这是不太好的 一个问题，那是不是意味着Controller里面要写全部的输入逻辑？ 不是的，输入逻辑写在哪里，关键看这个Pawn有没有这个功能，比如攻击、跳跃，这种接受输入的逻辑应当写在Pawn（Character）里，因为这是只有角色才有的功能，而Controller经过Unreal的封装，虽然写在了Pawn里，但由于有Possess这个接口，但实际上还是由Controller告诉Pawn：请攻击、请跳跃的。 而另一方面，一些“不是这个Pawn该有的功能”的输入操作，则应该写在Controller里，比如暂停、调出UI，应当写在Controller里 另一个问题，如果不同的Pawn之间有一些通用的功能，比如Character可以Fire，而炮塔也可以Fire，PlayerController既可以Possess炮塔，也可以Possess Character，那么接受Fire的输入的逻辑应该写在哪里呢？ 在我去翻项目工程之前，我自己的想法是在PlayerController里写Fire输入，Fire本身作为一个FireActorComponent，然后派生出炮塔FireActorComponent和CharacterFireActorComponent，分别实现Fireable接口中Fire()函数，PlayerController里Fire输入事件判断当前Pawn是否实现该接口 工程中则直接采用了接口，取消了一层AcotrComponent的继承关系，直接在炮塔BP和CharacterBP中实现接口。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:3:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"AController和APlayerState ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"AController 用来控制别的Actor的Actor ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:1","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"APlayerState 肉体的状态（抽离开是为了联机复制） ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:2","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"AIController AI是否有PlayerState？有，有一个Property是bWantsPlayerState ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:4:3","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ULevel和UWorld ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:5:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"ULevel Actor的集合 World里的板块 对应umap ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:5:1","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"UWorld Level的集合 运行时，真正的Actor集合 “关卡”的真正单位 场景的真正表示对象 这个层级关系，主要还是涉及到StreamingLevel相关，详见InsideUE即可。 总之这里比较重要的还是强调一下，不要在关卡里写逻辑。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:5:2","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"GameMode和GameState GameMode实际上是定义的世界（World）的规则，可以理解成WorldMode，它来控制UWorld “上帝的意志” GameState则表示世界的状态 一个问题：如果有关于世界的规则越来越多，那么GameMode中的逻辑也会变得很庞大，该如何处理这种情况？ 见Subsystem ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:6:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"GameInstance和SaveGame GameInstance是正常游戏的全局示例 World的外围管理对象 所以会写一些跨关卡的逻辑 比如，存档，由于存档实在是太重要了，所以Unreal专门写了一个USaveGame类给开发者使用 SaveGame就是GameInstance层级的一个数据对象，当然，根据我的理解，GameInstance里也可以存放一些数据，这些数据是不需要进行序列化保存到本地，只需要在游戏运行期间使用就行的（当然要符合GameInstance这个层级），而需要保存到本地的则放在SaveGame里。 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:7:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"USubsystem 业务逻辑的组件 5个生命周期粒度控制 自动生成对象 托管生命周期 替代Manager类 详见InsideUE ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:8:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"UI 创建UI，比较推荐写在PlayerController里，不要写在GameMode或者关卡蓝图里 这个是涉及一个联机问题，因为GameMode是不会在客户端里的，理论上单机游戏创建UI写在哪里都行，但是一旦联机还是写在本地会有的关联性也比较强的PlayerController里为好 或者，考虑Subsystem ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:9:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"总结：什么逻辑在那里 Component：功能、能力 Actor：个体本身的逻辑 Apawn、APlayerController、APlayerState：主角肉体、灵魂、状态 APawn、AAIController、APlayerState：AI肉体、灵魂、状态 AAIController、BehaviorTree：AI灵魂、行为树、数据 AGameMode、AGameState：游戏规则、游戏状态 UGameInstance、USaveGame：全局游戏实例、游戏存档 USubsystem：游戏逻辑组件 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:10:0","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Unreal"],"content":"输入事件在那里处理 考虑联机扩展 APlayerController最优先 APawn其次 单独Actor且EnableInput 关卡蓝图：Demo测试 ","date":"2022-11-05","objectID":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/:10:1","tags":["临阵磨枪","Gameplay","Unreal","笔记"],"title":"【临阵磨枪】哪些逻辑写在哪里——Unreal Gameplay框架简要","uri":"/posts/%E4%B8%B4%E9%98%B5%E7%A3%A8%E6%9E%AA%E5%93%AA%E4%BA%9B%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8Cunreal-gameplay%E6%A1%86%E6%9E%B6%E7%AE%80%E8%A6%81/"},{"categories":["Dev"],"content":"最基础的：斜体、加粗、粗斜体、Inline代码、删除线 ToDo Done ","date":"2022-10-29","objectID":"/posts/first/:0:0","tags":["格式"],"title":"内容格式参考模板","uri":"/posts/first/"},{"categories":["Dev"],"content":"一级标题 ","date":"2022-10-29","objectID":"/posts/first/:1:0","tags":["格式"],"title":"内容格式参考模板","uri":"/posts/first/"},{"categories":["Dev"],"content":"二级标题 三级标题 四级标题 引 用 简单代码块 有 序 列 表 无 序 列 表 嵌 套 列 表 公式： 在markdown中使用KaTeX公式，遇到 _ * \u003e\u003e \\( \\) \\{ \\} \\] \\[ 在前面都需要添加转义符 \\ 比较保险。 对于 \\\\ ，需要写成 \\\\\\\\ 公式块： $$ C(n,m)=\\frac{n*(n-1)*…*(n-m+1)}{m*(m-1)*…*1} $$ $$P(A|B)=\\cfrac{P(A)*P(B|A)}{P(B)}$$ 行内公式1： \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 行内公式2： \\(\\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots\\) 矩阵：$$\\begin{matrix} 1\u00262 \\\\ 3\u00264 \\\\ 5\u00266 \\end{matrix} $$ $$\\left\\{ \\begin{matrix} 1\u00262 \\\\ 3\u00264 \\\\ 5\u00266 \\end{matrix} \\right\\} $$ $$\\left[ \\begin{matrix} 1\u00262 \\\\ 3\u00264 \\\\ 5\u00266 \\end{matrix} \\right] $$ 快速分数： 99/100 额外空行： 表格： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 脚注： 使用1表示脚注 链接： 这是一个连接 加强代码块： #include \u003ciostream\u003e int main() { std::cout\u003c\u003c(\"Hello world!\"); return 0; } Admonition shortcode： tip\rA tip banner\rnote\rA note banner\rinfo\rA info banner\rSuccess\rA success banner\rabstract\rA abstract banner\rquestion\rA question banner\rwarning\rA warning banner\rfailure\rA failure banner\rdanger\rA danger banner\rbug\rA bug banner\rexample\rA example banner\rquote\rA quote banner\r添加B站视频（Youtube同理）： 添加本地音乐： 添加平台音乐（第二个参数song或者playlist或者album或者artist都行）： 添加平台音乐2： 添加脚本： 图片： 带脚注图片： 这样会自动放缩并居中\r行内图片，自定义大小： 图片居中，自定义大小，带脚注： 这是一个脚注 ↩︎ ","date":"2022-10-29","objectID":"/posts/first/:1:1","tags":["格式"],"title":"内容格式参考模板","uri":"/posts/first/"},{"categories":["Unreal","Game","GameDesign","GameDev","GameReview","PersonalWork","Dev","MeMe","Ramble","Other"],"content":" ","date":"2022-10-29","objectID":"/quickpost/:0:0","tags":null,"title":"查询精神状态","uri":"/quickpost/"}]